---------------------------------------------------------------------------
--
--  (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--
---------------------------------------------------------------------------
-- Description:
-- This is an example testbench for the Reed-Solomon Decoder IP core.
-- The testbench has been generated by Vivado to accompany the IP core
-- instance you have generated.
--
-- This testbench is for demonstration purposes only.  See note below for
-- instructions on how to use it with the netlist created for your core.
--
-- See the RS Decoder datasheet for further information about this core.
--
---------------------------------------------------------------------------
-- Using this testbench
--
-- This testbench instantiates your generated Reed-Solomon Decoder core
-- named "rs_decoder_1".
--
-- Use Vivado's Run Simulation flow to run this testbench.  See the Vivado
-- documentation for details.
---------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

-- Use function package to perform RS encoding
use work.rs_decoder_v9_0_12_demo_tb_pkg.all;

entity tb_rs_decoder_1 is
end tb_rs_decoder_1;

architecture tb of tb_rs_decoder_1 is

  -----------------------------------------------------------------------
  -- Timing constants
  -----------------------------------------------------------------------
  constant CLOCK_PERIOD : time := 100 ns;
  constant T_HOLD       : time := 10 ns;
  constant T_STROBE     : time := CLOCK_PERIOD - (1 ns);

  -----------------------------------------------------------------------
  -- DUT signals
  -----------------------------------------------------------------------

  -- Global signals
  signal aclk                           : std_logic := '0';  -- the master clock
  signal aresetn                        : std_logic := '1';  -- synchronous active low reset

  -- Input slave channel signals
  signal s_axis_input_tvalid            : std_logic := '0';  -- payload is valid
  signal s_axis_input_tready            : std_logic := '1';  -- slave is ready
  signal s_axis_input_tdata             : std_logic_vector(7 downto 0) := (others => '0');  -- data payload
  signal s_axis_input_tlast             : std_logic := '0';  -- indicates end of packet

  -- Output master channel signals
  signal m_axis_output_tvalid           : std_logic := '0';  -- payload is valid
  signal m_axis_output_tready           : std_logic := '1';  -- receiving slave is ready
  signal m_axis_output_tdata            : std_logic_vector(7 downto 0) := (others => '0');  -- data payload
  signal m_axis_output_tlast            : std_logic := '0';  -- indicates end of packet

  -- Status master channel signals
  signal m_axis_stat_tvalid             : std_logic := '0';  -- payload is valid
  signal m_axis_stat_tready             : std_logic := '1';  -- receiving slave is ready
  signal m_axis_stat_tdata              : std_logic_vector(7 downto 0) := (others => '0');  -- data payload

  -- Event signals
  signal event_s_input_tlast_missing    : std_logic := '0';  -- s_axis_input_tlast low when it should be high
  signal event_s_input_tlast_unexpected : std_logic := '0';  -- s_axis_input_tlast high when it should be low
  signal event_s_ctrl_tdata_invalid     : std_logic := '0';  -- s_axis_ctrl_tdata contained invalid value

  -----------------------------------------------------------------------
  -- Aliases for AXI channel TDATA and TUSER fields
  -- These are a convenience for viewing data in a simulator waveform viewer.
  -- If using ModelSim or Questa, add "-voptargs=+acc=n" to the vsim command
  -- to prevent the simulator optimizing away these signals.
  -----------------------------------------------------------------------

  -- Input slave channel alias signals
  signal s_axis_input_tdata_data_in          : std_logic_vector(7 downto 0) := (others => '0');  -- DATA_IN field

  -- Output master channel alias signals
  signal m_axis_output_tdata_data_out        : std_logic_vector(7 downto 0) := (others => '0');  -- DATA_OUT field

  -- Status master channel alias signals
  signal m_axis_stat_tdata_fail              : std_logic := '0';  -- FAIL field
  signal m_axis_stat_tdata_err_found         : std_logic := '0';  -- ERR_FOUND field
  signal m_axis_stat_tdata_err_cnt           : std_logic_vector(4 downto 0) := (others => '0');  -- ERR_CNT field

  -----------------------------------------------------------------------
  -- Testbench constants, types and functions to create input data
  -----------------------------------------------------------------------

  type t_src_table is array (0 to 238) of std_logic_vector(7 downto 0);

  -- Function to generate source data table to be RS-encoded to form input data
  -- Data is a sinusoid with a period equal to the input code block size
  function create_src_table return t_src_table is
    variable result   : t_src_table;
    variable theta    : real;
    variable sin_real : real;
    variable sin_int  : integer;
  begin
    for i in 0 to 238 loop
      theta     := real(i) / real(239) * 2.0 * MATH_PI;
      sin_real  := sin(theta);
      sin_int   := integer(round(sin_real * real(2**7 - 1)));
      result(i) := std_logic_vector(to_signed(sin_int, 8));
      --result(i) := std_logic_vector(to_unsigned(i, 8));
    end loop;
    return result;
  end function create_src_table;

  -- Call the function to create the source data
  constant SRC_DATA : t_src_table := create_src_table;

  -- The source data will be RS-encoded to form the RS Decoder input data before starting each RS Decoder codeblock.

  -----------------------------------------------------------------------
  -- Testbench types and signals
  -----------------------------------------------------------------------

  -- Overall simulation phase control enumerated type and signal
  type t_sim_phase is (phase_init,           -- testbench initialization
                       phase_no_errors,      -- decode a codeblock containing no errors
                       phase_correct_errors, -- decode and correct a codeblock containing errors
                       phase_toomany_errors, -- fail to correct a codeblock containing too many errors
                       phase_continuous,     -- decode 20 codeblocks, streaming data continuously
                       phase_axi_handshake,  -- decode 10 more codeblocks, manipulating AXI handshake signals
                       phase_aresetn,        -- demonstrate the use of synchronous reset
                       phase_end             -- end of simulation
                       );
  signal sim_phase : t_sim_phase := phase_init;

  -- Testbench information signals, to make viewing simulation waveforms easier
  signal input_errors    : integer := 0;  -- Number of errors applied to the codeblock being input


begin

  -----------------------------------------------------------------------
  -- Instantiate the DUT
  -----------------------------------------------------------------------

  dut : entity work.rs_decoder_1
    port map (
      -- Global signals
      aclk                           => aclk,
      aresetn                        => aresetn,
    -- AXI4-Stream slave channel for input data
      s_axis_input_tvalid            => s_axis_input_tvalid,
      s_axis_input_tready            => s_axis_input_tready,
      s_axis_input_tdata             => s_axis_input_tdata,
      s_axis_input_tlast             => s_axis_input_tlast,
      -- AXI4-Stream master channel for output data
      m_axis_output_tvalid           => m_axis_output_tvalid,
      m_axis_output_tready           => m_axis_output_tready,
      m_axis_output_tdata            => m_axis_output_tdata,
      m_axis_output_tlast            => m_axis_output_tlast,
      -- AXI4-Stream master channel for output status
      m_axis_stat_tvalid             => m_axis_stat_tvalid,
      m_axis_stat_tready             => m_axis_stat_tready,
      m_axis_stat_tdata              => m_axis_stat_tdata,
      -- Event signals
      event_s_input_tlast_missing    => event_s_input_tlast_missing,
      event_s_input_tlast_unexpected => event_s_input_tlast_unexpected,
      event_s_ctrl_tdata_invalid     => event_s_ctrl_tdata_invalid
      );


  -----------------------------------------------------------------------
  -- Generate clock
  -----------------------------------------------------------------------

  clock_gen : process
  begin
    aclk <= '0';
    wait for CLOCK_PERIOD;
    loop
      aclk <= '0';
      wait for CLOCK_PERIOD/2;
      aclk <= '1';
      wait for CLOCK_PERIOD/2;
    end loop;
  end process clock_gen;


  -----------------------------------------------------------------------
  -- Simulation control
  -- Run a series of demonstrations, each in a separate test phase
  -- This process controls all other stimuli processes
  -----------------------------------------------------------------------

  sim_control : process
  begin

    -- Drive simulation control synchronous to the rising edge of the clock
    wait until rising_edge(aclk);

    -- Decode a codeblock containing no errors
    sim_phase <= phase_no_errors;
    wait until rising_edge(aclk) and
               m_axis_output_tvalid = '1' and m_axis_output_tready = '1' and m_axis_output_tlast = '1';
    wait for 5 * CLOCK_PERIOD;

    -- Decode and correct a codeblock containing errors
    sim_phase <= phase_correct_errors;
    wait until rising_edge(aclk) and
               m_axis_output_tvalid = '1' and m_axis_output_tready = '1' and m_axis_output_tlast = '1';
    wait for 5 * CLOCK_PERIOD;

    -- Fail to correct a codeblock containing too many errors
    sim_phase <= phase_toomany_errors;
    wait until rising_edge(aclk) and
               m_axis_output_tvalid = '1' and m_axis_output_tready = '1' and m_axis_output_tlast = '1';
    wait for 5 * CLOCK_PERIOD;

    -- Decode 20 codeblocks, streaming data continuously
    sim_phase <= phase_continuous;
    for i in 1 to 20 loop
      wait until rising_edge(aclk) and
                 m_axis_output_tvalid = '1' and m_axis_output_tready = '1' and m_axis_output_tlast = '1';
    end loop;
    wait for 5 * CLOCK_PERIOD;

    -- Decode 10 more codeblocks, manipulating AXI handshake signals
    sim_phase <= phase_axi_handshake;
    for i in 1 to 10 loop
      wait until rising_edge(aclk) and
                 m_axis_output_tvalid = '1' and m_axis_output_tready = '1' and m_axis_output_tlast = '1';
    end loop;
    wait for 5 * CLOCK_PERIOD;

    -- Demonstrate the use of synchronous reset
    sim_phase <= phase_aresetn;
    wait until rising_edge(aclk) and
               m_axis_output_tvalid = '1' and m_axis_output_tready = '1' and m_axis_output_tlast = '1';
    wait for 5 * CLOCK_PERIOD;

    -- End of simulation
    sim_phase <= phase_end;
    wait for CLOCK_PERIOD;
    report "Not a real failure. Simulation finished successfully. Test completed successfully" severity failure;
    wait;

  end process sim_control;


  -----------------------------------------------------------------------
  -- Generate input slave channel inputs
  -----------------------------------------------------------------------

  input_stimuli : process

    -- Variables for random number generation
    variable seed1, seed2 : positive;
    variable rand         : real;

    -- Procedure to drive a single symbol on the input channel
    -- valid_mode defines how to drive TVALID: 0 = TVALID always high, otherwise TVALID low 1 in valid_mode cycles
    -- tdata and tlast are the transaction payload
    -- abort is set if a reset aborts the transaction
    procedure drive_input_symbol(tdata          : std_logic_vector(7 downto 0);
                                 tlast          : std_logic;
                                 valid_mode     : integer := 0;
                                 variable abort : out boolean) is
    begin
      -- Drive AXI payload signals
      s_axis_input_tdata <= tdata;
      s_axis_input_tlast <= tlast;

      -- Drive AXI control signal TVALID
      if valid_mode > 0 then
        uniform(seed1, seed2, rand);  -- generate random number
        if rand < 1.0 / real(valid_mode) then
          s_axis_input_tvalid <= '0';  -- deassert TVALID
          uniform(seed1, seed2, rand);  -- generate another random number
          wait for CLOCK_PERIOD * integer(ceil(rand * 4.0));  -- hold low for up to 4 cycles
        end if;
      end if;
      s_axis_input_tvalid <= '1';  -- assert TVALID
      abort := false;
      loop
        wait until rising_edge(aclk);
        if aresetn = '0' then
          abort := true;
          exit;
        end if;
        exit when s_axis_input_tready = '1';
      end loop;
      wait for T_HOLD;
      s_axis_input_tvalid <= '0';
    end procedure drive_input_symbol;

    -- Procedure to drive a code block on the input channel,
    -- generating input data by RS-encoding the pregenerated source data table
    -- errors is the number of symbols with errors added between encoder and decoder
    procedure drive_input_codeblock(errors       : integer := 0;
                                    valid_mode   : integer := 0) is
      subtype t_encode_in  is t_codeblock(0 to 238);
      subtype t_encode_out is t_codeblock(0 to 254);
      type t_decode_in is array (0 to 254) of std_logic_vector(7 downto 0);
      type t_encode_flags is array (0 to 254) of std_logic;
      variable encode_in       : t_encode_in := (others => (others => '0'));
      variable encode_out      : t_encode_out;
      variable decode_in       : t_decode_in;
      variable rand_range      : integer;
      variable rand_offset     : integer;
      variable error_symbols   : t_encode_flags := (others => '0');
      variable pre_error_value : std_logic_vector(7 downto 0);
      variable index           : integer;
      variable tdata           : std_logic_vector(7 downto 0);
      variable tlast           : std_logic;
      variable abort           : boolean;
    begin

      -- Testbench information signals: indicate the parameters of this input codeblock
      input_errors    <= errors;

      -- RS-encode the pregenerated source data table to create the input codeblock
      -- The RS-encode function supports the full range of symbol widths, so requires data in max symbol width format
      for i in 0 to 238 loop
        encode_in(i)(7 downto 0) := SRC_DATA(i);  -- convert to max symbol width format
      end loop;
      encode_out := rs_encode(encode_in, 0, 1, 239, 255, 285, 0, 8);

      -- Convert encoded data back to correct symbol width for input to the decoder core
      for i in 0 to 254 loop
        decode_in(i) := encode_out(i)(7 downto 0);
      end loop;

      -- Add errors to the encoded codeblock as required, to demonstrate the decoder's error correction capabilities
      -- Errors are added by replacing randomly selected symbols (either data or check symbols) with random data
      -- However, if at least 2 errors are requested, make at least 1 data symbol and at least 1 check symbol in error
      error_gen : for i in 1 to errors loop
        error_check : loop  -- check errors are in separate symbols
          case i is         -- try to make at least 1 data symbol and at least 1 check symbol in error
            when 1 =>       -- make first error always in a data symbol
              rand_range  := 239;
              rand_offset := 0;
            when 2 =>       -- make second error always in a check symbol
              rand_range  := 16;
              rand_offset := 239;
            when others =>  -- following errors can be in any symbol
              rand_range  := 255;
              rand_offset := 0;
          end case;
          uniform(seed1, seed2, rand);  -- generate random number
          index := integer(floor(rand * real(rand_range))) + rand_offset;
          exit error_check when error_symbols(index) = '0';  -- selected symbol is not already in error
        end loop error_check;
        error_symbols(index) := '1';
      end loop error_gen;

      -- Apply the errors, making sure that the symbols with errors are changed
      if errors > 0 then
        for i in 0 to 254 loop
          if error_symbols(i) = '1' then
            pre_error_value := decode_in(i);
            while decode_in(i) = pre_error_value loop  -- to ensure that the new random value is different
              uniform(seed1, seed2, rand);  -- generate random number
              decode_in(i) := std_logic_vector(to_unsigned(integer(floor(rand * real(2**8))), 8));
            end loop;
          end if;
        end loop;
      end if;

      -- Drive the encoded data with errors into the RS Decoder, one symbol at a time
      codeblock_loop : for i in 0 to 254 loop
        -- Look up sample data in encoded data table, construct TDATA value
        tdata(7 downto 0) := decode_in(i);  -- DATA_IN field
        -- TLAST indicates the last symbol in the input code block
        if i = 254 then
          tlast := '1';
        else
          tlast := '0';
        end if;

        -- Drive the AXI transaction
        drive_input_symbol(tdata      => tdata,
                           tlast      => tlast,
                           valid_mode => valid_mode,
                           abort      => abort);

        exit codeblock_loop when abort;  -- abort all transactions if reset occurred
      end loop codeblock_loop;
    end procedure drive_input_codeblock;

    -- Variables for selecting the number of errors to put in a codeblock
    variable errors       : integer;
    constant max_errors   : integer := 8;

  begin

    -- Wait for simulation control to signal the first phase
    wait until sim_phase = phase_no_errors;
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Decode a codeblock containing no errors
    drive_input_codeblock;

    -- Wait for simulation control to signal the next phase
    wait until sim_phase = phase_correct_errors;
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Decode and correct a codeblock containing errors
    drive_input_codeblock(errors => max_errors);

    -- Wait for simulation control to signal the next phase
    wait until sim_phase = phase_toomany_errors;
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Fail to correct a codeblock containing too many errors
    drive_input_codeblock(errors => max_errors + 1);

    -- Wait for simulation control to signal the next phase
    wait until sim_phase = phase_continuous;
    wait until rising_edge(aclk);  -- synchronize to the clock
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock
    -- Decode 20 codeblocks, streaming data continuously
    -- Put errors in each codeblock, but few enough that every codeblock is decoded and corrected
    for i in 1 to 20 loop

      -- Select the number of errors
      uniform(seed1, seed2, rand);  -- generate random number
      errors := integer(floor(rand * real(max_errors + 1)));

      -- Generate and drive the input codeblock data
      drive_input_codeblock(errors       => errors);

    end loop;

    -- Wait for simulation control to signal the next phase
    wait until sim_phase = phase_axi_handshake;
    wait until rising_edge(aclk);  -- synchronize to the clock
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Decode 10 more codeblocks, manipulating AXI handshake signals
    -- Put errors in each codeblock, but few enough that every codeblock is decoded and corrected
    for i in 1 to 10 loop

      -- Select the number of errors
      uniform(seed1, seed2, rand);  -- generate random number
      errors := integer(floor(rand * real(max_errors + 1)));

      -- Generate and drive the input codeblock data
      drive_input_codeblock(errors       => errors,
                            valid_mode   => 12 - i);  -- gradually increase how often TVALID is low

    end loop;

    -- Wait for simulation control to signal the next phase
    wait until sim_phase = phase_aresetn;
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Demonstrate the use of synchronous reset
    drive_input_codeblock(errors       => 1);

    -- That codeblock will be aborted by a reset.  After the reset, drive the codeblock again.
    wait until rising_edge(aclk) and aresetn = '0';  -- synchronous reset is active low
    wait until rising_edge(aclk) and aresetn = '1';  -- wait until the reset is released
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Drive the codeblock again
    drive_input_codeblock(errors       => 1);

    -- End of test
    wait;

  end process input_stimuli;


  -----------------------------------------------------------------------
  -- Generate output master channel TREADY input
  -----------------------------------------------------------------------

  output_tready_stimuli : process

    -- Variables for random number generation
    variable seed1, seed2 : positive;
    variable rand         : real;

    -- Codeblock number tracking
    variable axi_handshake_output_codeblock : integer := 1;

  begin

    -- Output channel TREADY is high in all phases except AXI handshake manipulation phase
    m_axis_output_tready <= '1';
    wait until sim_phase = phase_axi_handshake;
    wait until rising_edge(aclk);  -- synchronize to the clock
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Decode 10 more codeblocks, manipulating AXI handshake signals
    -- Gradually decrease how often TREADY is low
    while sim_phase = phase_axi_handshake loop

      -- Drive AXI control signal TREADY
      uniform(seed1, seed2, rand);  -- generate random number
      if rand < 1.0 / real(axi_handshake_output_codeblock) then
        m_axis_output_tready <= '0';  -- deassert TREADY
        uniform(seed1, seed2, rand);  -- generate another random number
        wait for CLOCK_PERIOD * integer(ceil(rand * 10.0));  -- hold low for up to 10 cycles
      end if;
      m_axis_output_tready <= '1';  -- assert TREADY

    -- Keep track of the output codeblock number
      wait until rising_edge(aclk);
      if m_axis_output_tvalid = '1' and m_axis_output_tlast = '1' and aresetn = '1' then
        axi_handshake_output_codeblock := axi_handshake_output_codeblock + 1;
      end if;
      wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    end loop;

    -- End of test
    wait;

  end process output_tready_stimuli;


  -----------------------------------------------------------------------
  -- Generate synchronous reset input
  -----------------------------------------------------------------------

  aresetn_stimuli : process
  begin

    -- Synchronous reset input is active low.
    -- Synchronous reset is high (inactive) in all phases except reset demonstration
    aresetn <= '1';
    wait until sim_phase = phase_aresetn;

    -- A codeblock is processed by the core.
    -- Wait until the core starts to output data, then reset the core.
    -- Note that reset must be asserted for a minimum of two clock cycles (see the datasheet for details).
    wait until rising_edge(aclk) and m_axis_output_tvalid = '1' and m_axis_output_tready = '1';
    wait for CLOCK_PERIOD * 2;  -- allow two symbols to be output
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Assert reset for two clock cycles
    aresetn <= '0';  -- reset is active low
    wait for CLOCK_PERIOD * 2;
    aresetn <= '1';

    -- End of test
    wait;

  end process aresetn_stimuli;


  -----------------------------------------------------------------------
  -- Check outputs
  -----------------------------------------------------------------------

  check_outputs : process

    -- Variables for checking the protocol of the output and status master channels
    variable check_ok : boolean := true;
    -- Previous values of output master channel signals
    variable output_tvalid_prev : std_logic := '0';
    variable output_tready_prev : std_logic := '0';
    variable output_tdata_prev  : std_logic_vector(7 downto 0) := (others => '0');
    variable output_tlast_prev  : std_logic := '0';
    -- Previous values of status master channel signals
    variable stat_tvalid_prev : std_logic := '0';
    variable stat_tready_prev : std_logic := '0';
    variable stat_tdata_prev  : std_logic_vector(7 downto 0) := (others => '0');

    -- Variables for checking the decoded, error-corrected output data matches the source data
    variable output_symbol    : integer := 0;

  begin

    -- Check outputs T_STROBE time after rising edge of clock
    wait until rising_edge(aclk);
    wait for T_STROBE;

    -- First, check the protocol of the output and status master channels:
    -- check that the payload is valid (not X) when TVALID is high
    -- and check that the payload does not change while TVALID is high until TREADY goes high

    if m_axis_output_tvalid = '1' and aresetn = '1' then
      if is_x(m_axis_output_tdata) then
        report "ERROR: m_axis_output_tdata is invalid when m_axis_output_tvalid is high" severity error;
        check_ok := false;
      end if;
      if is_x(m_axis_output_tlast) then
        report "ERROR: m_axis_output_tlast is invalid when m_axis_output_tvalid is high" severity error;
        check_ok := false;
      end if;

      if output_tvalid_prev = '1' and output_tready_prev = '0' then  -- payload must be the same as last cycle
        if m_axis_output_tdata /= output_tdata_prev then
          report "ERROR: m_axis_output_tdata changed while m_axis_output_tvalid was high and m_axis_output_tready was low" severity error;
          check_ok := false;
        end if;
        if m_axis_output_tlast /= output_tlast_prev then
          report "ERROR: m_axis_output_tlast changed while m_axis_output_tvalid was high and m_axis_output_tready was low" severity error;
          check_ok := false;
        end if;
      end if;

    end if;

    if m_axis_stat_tvalid = '1' and aresetn = '1' then
      if is_x(m_axis_stat_tdata) then
        report "ERROR: m_axis_stat_tdata is invalid when m_axis_stat_tvalid is high" severity error;
        check_ok := false;
      end if;

      if stat_tvalid_prev = '1' and stat_tready_prev = '0' then  -- payload must be the same as last cycle
        if m_axis_stat_tdata /= stat_tdata_prev then
          report "ERROR: m_axis_stat_tdata changed while m_axis_stat_tvalid was high and m_axis_stat_tready was low" severity error;
          check_ok := false;
        end if;
      end if;

    end if;

    -- Record payload values for checking next clock cycle
    if check_ok then
      output_tvalid_prev := m_axis_output_tvalid;
      output_tready_prev := m_axis_output_tready;
      output_tdata_prev  := m_axis_output_tdata;
      output_tlast_prev  := m_axis_output_tlast;
      stat_tvalid_prev   := m_axis_stat_tvalid;
      stat_tready_prev   := m_axis_stat_tready;
      stat_tdata_prev    := m_axis_stat_tdata;
    end if;

    -- Now, check the decoded, error-corrected output data matches the source data
    -- Do not check at all in simulation phases where error correction is expected to fail
    if sim_phase /= phase_toomany_errors then
      if m_axis_output_tvalid = '1' and m_axis_output_tready = '1' and aresetn = '1' then
        if output_symbol < 239 then  -- only check data symbols, not check symbols
          if m_axis_output_tdata(7 downto 0) /= SRC_DATA(output_symbol) then
            report "ERROR: error-corrected output data on m_axis_output_tdata does not match source data in SRC_DATA table for symbol number " & integer'image(output_symbol) severity error;
            check_ok := false;
          end if;
        end if;

        output_symbol := output_symbol + 1;

        if m_axis_output_tlast = '1' then  -- end of output codeblock
          output_symbol := 0;
        end if;
      end if;
    end if;

    -- Treat a reset like the end of an output codeblock
    if aresetn = '0' then
      output_symbol := 0;
    end if;

    -- Stop if any check failed
    assert check_ok
      report "ERROR: terminating test with failures." severity failure;

  end process check_outputs;


  -----------------------------------------------------------------------
  -- Assign TDATA / TUSER fields to aliases, for easy simulator waveform viewing
  -----------------------------------------------------------------------

  -- Input slave channel alias signals
  s_axis_input_tdata_data_in          <= s_axis_input_tdata(7 downto 0);

  -- Output master channel alias signals
  m_axis_output_tdata_data_out        <= m_axis_output_tdata(7 downto 0);

  -- Status master channel alias signals
  m_axis_stat_tdata_fail              <= m_axis_stat_tdata(0);
  m_axis_stat_tdata_err_found         <= m_axis_stat_tdata(1);
  m_axis_stat_tdata_err_cnt           <= m_axis_stat_tdata(6 downto 2);

end tb;
