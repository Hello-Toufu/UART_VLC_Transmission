-- $RCSfile: c_mux_bit_v12_0_3_viv_comp.vhd,v $ $Revision: 1.3 $ $Date: 2009/09/08 15:11:46 $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
-----------------------------------------------------------------------
--
-- Use VHDL package bb_comps to define black box components to be
-- generated by a synthesis tool.
--
-- This file should not be copied over to the export area
-- unless it is specifically required by the synthesis tool.
--
-- Try to ensue that the file-sets processed by XCC and the synthesis
-- tool is disjoint.
--
-----------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;

package c_mux_bit_v12_0_3_viv_comp is

----------------------------------------------------------
-- Insert component declaration of top level xst file here
----------------------------------------------------------
  component c_mux_bit_v12_0_3_viv
    generic (
      C_FAMILY        : string  := "virtex2";  -- Specifies device family being targeted
      C_XDEVICEFAMILY : string  := "virtex2";  -- Specifies device family being targeted
      C_INPUTS        : integer := 2;          -- Specifies input data bus width to mux
      C_SEL_WIDTH     : integer := 1;          -- Specifies select bus width
      C_PIPE_STAGES   : integer := 0;          -- Specifies number of pipeline stages in conj. with c_latency (0,1,2)
      C_LATENCY       : integer := 1;          -- Specifies latency of mux (0,1,2,3)
      C_HEIGHT        : integer := 0;          -- Redundant in VHDL core
      C_AINIT_VAL     : string  := "0";        -- Async init value, defaults to 0 in the code, init value for registers
      C_SINIT_VAL     : string  := "0";        -- Sync init value, redundant here
      C_SYNC_ENABLE   : integer := 0;          -- Priority of CE and sync controls - passed to o/p register
      C_SYNC_PRIORITY : integer := 1;          -- Priority of sync set and clear for output register
      C_HAS_O         : integer := 0;          -- Unregistered output
      C_HAS_Q         : integer := 1;          -- Registered output
      C_HAS_CE        : integer := 0;          -- Optional clock enable
      C_HAS_ACLR      : integer := 0;          -- Optional async clear
      C_HAS_ASET      : integer := 0;          -- Optional async set
      C_HAS_AINIT     : integer := 0;          -- Redundant async init - for interface only
      C_HAS_SCLR      : integer := 0;          -- Optional sync clear
      C_HAS_SSET      : integer := 0;          -- Optional sync set
      C_HAS_SINIT     : integer := 0;          -- Redundant sync init - for interface only
      C_ENABLE_RLOCS  : integer := 0           -- Redundant in VHDL core
      );

    port (
      M     : in  std_logic_vector(C_INPUTS-1 downto 0)    := (others => '0');  -- Input vector
      S     : in  std_logic_vector(C_SEL_WIDTH-1 downto 0) := (others => '0');  -- Select pin
      CLK   : in  std_logic                                := '0';              -- Optional clock
      CE    : in  std_logic                                := '1';              -- optional clock enable
      ASET  : in  std_logic                                := '0';              -- Optional asynch set '1'
      ACLR  : in  std_logic                                := '0';              -- Optional asynch clear to '0'
      AINIT : in  std_logic                                := '0';              -- Redundant in this version
      SSET  : in  std_logic                                := '0';              -- Optional synch set to '1'
      SCLR  : in  std_logic                                := '0';              -- Optional synch clear to '0'
      SINIT : in  std_logic                                := '0';              -- Redundant in this version
      O     : out std_logic                                := '0';              -- Output value
      Q     : out std_logic                                := '0'               -- Registered output value
      );
  end component;


end c_mux_bit_v12_0_3_viv_comp;


-- $RCSfile: c_mux_bit_v12_0_3_comp.vhd,v $ $Revision: 1.3 $ $Date: 2009/09/08 15:11:46 $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;

package c_mux_bit_v12_0_3_comp is


----- Component c_mux_bit_v12_0_3         -----
-- Short Description
--
-- (A)Synchronous N-to-1 Mux
--

  component c_mux_bit_v12_0_3
    generic (
      C_FAMILY        : string  := "virtex2";  -- Specifies device family being targeted
      C_XDEVICEFAMILY : string  := "virtex2";  -- Specifies device family being targeted
      C_INPUTS        : integer := 2;          -- Specifies input data bus width to mux
      C_SEL_WIDTH     : integer := 1;          -- Specifies select bus width
      C_PIPE_STAGES   : integer := 0;          -- Specifies number of pipeline stages in conj. with c_latency (0,1,2)
      C_LATENCY       : integer := 1;          -- Specifies latency of mux (0,1,2,3)
      C_HEIGHT        : integer := 0;          -- Redundant in VHDL core
      C_AINIT_VAL     : string  := "0";        -- Async init value, defaults to 0 in the code, init value for registers
      C_SINIT_VAL     : string  := "0";        -- Sync init value, redundant here
      C_SYNC_ENABLE   : integer := 0;          -- Priority of CE and sync controls - passed to o/p register
      C_SYNC_PRIORITY : integer := 1;          -- Priority of sync set and clear for output register
      C_HAS_O         : integer := 0;          -- Unregistered output
      C_HAS_Q         : integer := 1;          -- Registered output
      C_HAS_CE        : integer := 0;          -- Optional clock enable
      C_HAS_ACLR      : integer := 0;          -- Optional async clear
      C_HAS_ASET      : integer := 0;          -- Optional async set
      C_HAS_AINIT     : integer := 0;          -- Redundant async init - for interface only
      C_HAS_SCLR      : integer := 0;          -- Optional sync clear
      C_HAS_SSET      : integer := 0;          -- Optional sync set
      C_HAS_SINIT     : integer := 0;          -- Redundant sync init - for interface only
      C_ENABLE_RLOCS  : integer := 0           -- Redundant in VHDL core
      );

    port (
      M     : in  std_logic_vector(C_INPUTS-1 downto 0)    := (others => '0');  -- Input vector
      S     : in  std_logic_vector(C_SEL_WIDTH-1 downto 0) := (others => '0');  -- Select pin
      CLK   : in  std_logic                                := '0';              -- Optional clock
      CE    : in  std_logic                                := '1';              -- optional clock enable
      ASET  : in  std_logic                                := '0';              -- Optional asynch set '1'
      ACLR  : in  std_logic                                := '0';              -- Optional asynch clear to '0'
      AINIT : in  std_logic                                := '0';              -- Redundant in this version
      SSET  : in  std_logic                                := '0';              -- Optional synch set to '1'
      SCLR  : in  std_logic                                := '0';              -- Optional synch clear to '0'
      SINIT : in  std_logic                                := '0';              -- Redundant in this version
      O     : out std_logic                                := '0';              -- Output value
      Q     : out std_logic                                := '0'               -- Registered output value
      );
  end component;


END c_mux_bit_v12_0_3_comp;


-- $Id: c_mux_bit_v12_0_3_pkg.vhd,v 1.3 2009/09/08 15:11:45 akennedy Exp $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--------------------------------------------------------------------------------
--
-- package for constants, functions and utils specific to the mux_bit BaseBlock
--
---------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY xbip_utils_v3_0_7;
USE xbip_utils_v3_0_7.xbip_utils_v3_0_7_pkg.ALL;

PACKAGE c_mux_bit_v12_0_3_pkg IS

  -------------------------------------------------------------------------------
  -- Component declarations for sub-muxes
  -------------------------------------------------------------------------------
  
  COMPONENT c_mux_bit_4to1 IS
    GENERIC (
      pipelined_sub_mux : BOOLEAN := false;  -- specifies if the mux feeds into a pipeline register
      c_sync_priority   : INTEGER := 1;
      c_sync_enable     : INTEGER := 0;
      c_has_aclr        : INTEGER := 0;
      c_has_aset        : INTEGER := 0;
      c_has_sclr        : INTEGER := 0;
      c_has_sset        : INTEGER := 0);
    PORT (
      data : IN  STD_LOGIC_VECTOR(3 DOWNTO 0);
      sel  : IN  STD_LOGIC_VECTOR(1 DOWNTO 0);
      sclr : IN  STD_LOGIC;
      sset : IN  STD_LOGIC;
      o    : OUT STD_LOGIC);
  END COMPONENT c_mux_bit_4to1;

  COMPONENT c_mux_bit_8to1 IS
    GENERIC (
      pipelined_sub_mux : BOOLEAN := false;  -- specifies if the mux feeds into a pipeline register
      c_sync_priority   : INTEGER := 1;
      c_sync_enable     : INTEGER := 0;
      c_has_aclr        : INTEGER := 0;
      c_has_aset        : INTEGER := 0;
      c_has_sclr        : INTEGER := 0;
      c_has_sset        : INTEGER := 0);
    PORT (
      data : IN  STD_LOGIC_VECTOR(7 DOWNTO 0);
      sel  : IN  STD_LOGIC_VECTOR(2 DOWNTO 0);
      sclr : IN  STD_LOGIC;
      sset : IN  STD_LOGIC;
      o    : OUT STD_LOGIC);
  END COMPONENT c_mux_bit_8to1;

  COMPONENT c_mux_bit_16to1 IS
    GENERIC (
      pipelined_sub_mux : BOOLEAN         := false;  -- specifies if the mux feeds into a pipeline register
      c_xdevicefamily   : string          := "no_family";
      c_sync_priority   : INTEGER         := 1;
      c_sync_enable     : INTEGER         := 0;
      c_has_aclr        : INTEGER         := 0;
      c_has_aset        : INTEGER         := 0;
      c_has_sclr        : INTEGER         := 0;
      c_has_sset        : INTEGER         := 0);
    PORT (
      data : IN  STD_LOGIC_VECTOR(15 DOWNTO 0);
      sel  : IN  STD_LOGIC_VECTOR(3 DOWNTO 0);
      sclr : IN  STD_LOGIC;
      sset : IN  STD_LOGIC;
      o    : OUT STD_LOGIC);
  END COMPONENT c_mux_bit_16to1;

  COMPONENT c_mux_bit_32to1 IS
    GENERIC (
      c_xdevicefamily   : string          := "no_family";
      c_sync_priority : INTEGER         := 1;
      c_sync_enable   : INTEGER         := 0;
      c_has_aclr      : INTEGER         := 0;
      c_has_aset      : INTEGER         := 0;
      c_has_sclr      : INTEGER         := 0;
      c_has_sset      : INTEGER         := 0);
    PORT (
      data : IN  STD_LOGIC_VECTOR(31 DOWNTO 0);
      sel  : IN  STD_LOGIC_VECTOR(4 DOWNTO 0);
      sclr : IN  STD_LOGIC;
      sset : IN  STD_LOGIC;
      o    : OUT STD_LOGIC);
  END COMPONENT c_mux_bit_32to1;

  COMPONENT c_mux_bit_pipereg IS
    GENERIC (
      c_mux_inputs         : INTEGER := 1;  -- number of inputs to the mux to determine o/p reg style
      c_use_reg_sync_ctrls : BOOLEAN := true;  -- allows use of component for the o/p reg too
      c_pipe_width         : INTEGER := 1;  -- width of the pipeline register (or o/p register)
      c_ainit_val          : STRING  := "0";
      c_sinit_val          : STRING  := "0";
      c_sync_enable        : INTEGER := 0;
      c_sync_priority      : INTEGER := 0;
      c_has_ce             : INTEGER := 0;
      c_has_aclr           : INTEGER := 0;
      c_has_aset           : INTEGER := 0;
      c_has_sclr           : INTEGER := 0;
      c_has_sset           : INTEGER := 0);
    PORT (
      d    : IN  STD_LOGIC_VECTOR(c_pipe_width-1 DOWNTO 0);
      clk  : IN  STD_LOGIC;
      ce   : IN  STD_LOGIC;
      aclr : IN  STD_LOGIC;
      aset : IN  STD_LOGIC;
      sclr : IN  STD_LOGIC;
      sset : IN  STD_LOGIC;
      q    : OUT STD_LOGIC_VECTOR(c_pipe_width-1 DOWNTO 0));
  END COMPONENT;

  -------------------------------------------------------------------------------
  -- End of component declarations
  -------------------------------------------------------------------------------

  FUNCTION fn_stretch_string (p_char : STRING; p_len : INTEGER) RETURN STRING;

  function check_generics(
    p_xdevicefamily : string;
    p_inputs        : integer;
    p_sel_width     : integer;
    p_height        : integer;
    p_latency       : integer;
    p_pipe_stages   : integer; 
    p_has_o         : integer;
    p_has_q         : integer; 
    p_has_aclr      : integer;
    p_has_aset      : integer;
    p_has_sclr      : integer;
    p_has_sset      : integer;
    p_has_ainit     : integer;
    p_has_sinit     : integer
    ) return integer;

END c_mux_bit_v12_0_3_pkg;

PACKAGE BODY c_mux_bit_v12_0_3_pkg IS

  -- add any function bodies here

  -- purpose: Checks for valid combinations of generics
  function check_generics(
    p_xdevicefamily : string;
    p_inputs        : integer;
    p_sel_width     : integer;
    p_height        : integer;
    p_latency       : integer;
    p_pipe_stages   : integer; 
    p_has_o         : integer;
    p_has_q         : integer; 
    p_has_aclr      : integer;
    p_has_aset      : integer;
    p_has_sclr      : integer;
    p_has_sset      : integer;
    p_has_ainit     : integer;
    p_has_sinit     : integer
    ) return integer is
  begin  -- FUNCTION check_generics

    assert p_inputs > 1 and p_inputs < 257
      report "ERROR: c_mux_bit_v12_0_3_viv: Multiplexer input width must be between 2 bits and 256 bits inclusive"
      severity failure;

    assert p_sel_width > 0 and p_sel_width < 9
      report "ERROR: c_mux_bit_v12_0_3_viv: Select input bus width must be between 1 and 8 bits wide"
      severity failure;

    case p_inputs is
      when 2 => assert p_sel_width = 1
                  report "ERROR: c_mux_bit_v12_0_3_viv: c_sel_width generic value should be 1 for this input width"
                  severity failure;
      when 3 to 4 => assert p_sel_width = 2
                       report "ERROR: c_mux_bit_v12_0_3_viv: c_sel_width generic value should be 2 for this input width"
                       severity failure;
      when 5 to 8 => assert p_sel_width = 3
                       report "ERROR: c_mux_bit_v12_0_3_viv: c_sel_width generic value should be 3 for this input width"
                       severity failure;
      when 9 to 16 => assert p_sel_width = 4
                        report "ERROR: c_mux_bit_v12_0_3_viv: c_sel_width generic value should be 4 for this input width"
                        severity failure;
      when 17 to 32 => assert p_sel_width = 5
                         report "ERROR: c_mux_bit_v12_0_3_viv: c_sel_width generic value should be 5 for this input width"
                         severity failure;
      when 33 to 64 => assert p_sel_width = 6
                         report "ERROR: c_mux_bit_v12_0_3_viv: c_sel_width generic value should be 6 for this input width"
                         severity failure;
      when 65 to 128 => assert p_sel_width = 7
                          report "ERROR: c_mux_bit_v12_0_3_viv: c_sel_width generic value should be 7 for this input width"
                          severity failure;
      when 129 to 256 => assert p_sel_width = 8
                           report "ERROR: c_mux_bit_v12_0_3_viv: c_sel_width generic value should be 8 for this input width"
                           severity failure;
      when others => assert false
                       report "ERROR: c_mux_bit_v12_0_3_viv: Invalid c_inputs value detected"
                       severity failure;
    end case;

    assert not(has_LUT6(p_xdevicefamily) and (p_has_aclr /= 0 or p_has_aset /= 0))
      report "ERROR: c_mux_bit_v12_0_3_viv: aclr and aset are not supported for LUT6 families"
      severity error;

    assert p_height = 0
      report "WARNING: c_mux_bit_v12_0_3_viv: c_height generic is redundant in this BaseBlock"
      severity warning;

    if p_latency = 0 then
      assert p_pipe_stages = 0
        report "ERROR: c_mux_bit_v12_0_3_viv: c_pipe_stages must be 0 when latency is zero"
        severity failure;
    elsif p_latency = 1 then
      assert p_pipe_stages = 0 or p_pipe_stages = 1
        report "ERROR: c_mux_bit_v12_0_3_viv: c_pipe_stages must be either 0 (no pipelining) or 1 (pipelined with async output)"
        severity failure;
    elsif p_latency = 2 then
      assert p_pipe_stages = 1
        report "ERROR: c_mux_bit_v12_0_3_viv: c_pipe_stages must be 1 for a latency of 2 (pipelined mux)"
        severity failure;
    elsif p_latency = 3 then
      assert p_pipe_stages = 2
        report "ERROR: c_mux_bit_v12_0_3_viv: c_pipe_stages must be 2 for a latency of 3 (pipelined mux)"
        severity failure;
    end if;

    if p_has_o = 0 and p_has_q = 0 then  -- no outputs!
      
      assert false
        report "ERROR: c_mux_bit_v12_0_3_viv: c_mux_bit must have at least one output - set c_has_o and/or c_has_q to 1"
        severity failure;
      
    elsif p_has_o /= 0 and p_has_q /= 0 then
      
      assert p_latency = 1
        report "ERROR: c_mux_bit_v12_0_3_viv: Latency can only be 1 when both registered and non-registered outputs are used"
        severity failure;
      
    elsif p_has_o /= 0 and p_has_q = 0 and p_pipe_stages = 0 then
      
      assert p_latency = 0
        report "ERROR: c_mux_bit_v12_0_3_viv: Latency must be zero when no registered output is used"
        severity failure;
      assert p_has_aclr = 0 and p_has_aset = 0 and p_has_sclr = 0 and p_has_sset = 0
        report "ERROR: c_mux_bit_v12_0_3_viv: Register control generics must be set to zero when only using an asynchronous output"
        severity failure;
      
    elsif p_has_o /= 0 and p_has_q = 0 and p_pipe_stages = 1 then  -- non-registered output - special case for bus mux
      
      assert p_has_aclr = 0 and p_has_aset = 0 and p_has_sclr = 0 and p_has_sset = 0
        report "ERROR: c_mux_bit_v12_0_3_viv: Register control generics must be set to zero when only using an asynchronous output"
        severity failure;
      
    elsif p_has_o = 0 and p_has_q /= 0 then

      -- Check latency generic is in valid range
      assert p_latency > 0 and p_latency < 4
        report "ERROR: c_mux_bit_v12_0_3_viv: c_latency generic value must be in the range 1 to 3 inclusive for a registered output"
        severity failure;

      -- Check for valid latency values depending on # inputs
      if p_inputs < 9 then
        assert p_latency = 1
          report "ERROR: c_mux_bit_v12_0_3_viv: A latency value greater than 1 is not possible for a mux size smaller than 9:1"
          severity failure;
      elsif p_inputs > 8 and p_inputs < 65 then
        assert p_latency = 1 or p_latency = 2
          report "ERROR: c_mux_bit_v12_0_3_viv: Latency values of 1 or 2 (pipelined) only are allowed for this number of mux inputs"
          severity failure;
      end if;

      -- Indicate that pipelining will be implemented
      if p_latency = 2 or p_latency = 3 then
        assert false report "NOTE: c_mux_bit_v12_0_3_viv: Pipelining the multiplexer" severity note;
      end if;
      
    end if;

    assert p_has_ainit = 0
      report "WARNING: c_mux_bit_v12_0_3_viv: AINIT pin is not supported in this core version - no AINIT functionality will be implemented"
      severity warning;

    assert p_has_sinit = 0
      report "WARNING: c_mux_bit_v12_0_3_viv: SINIT pin is not supported in this core version - no SINIT functionality will be implemented"
      severity warning;

    if (p_has_aclr /= 0 or p_has_aset /= 0) and (p_has_sclr /= 0 or p_has_sset /= 0) then
      if p_has_o /= 0 and p_has_q /= 0 then
        -- In most other cases where there is only the q output, if both
        -- controls are requested, the sync controls will be implemented in the LUTs,
        -- so performance will not be degraded as another layer of logic will not be added
        assert false
          report "WARNING: c_mux_bit_v12_0_3_viv: Including both asynchronous (aclr, aset) AND synchronous controls" &
          "(sclr, sset) can add a layer of logic and impact on performance"
          severity warning;
      end if;
      if p_latency > 1 then
        assert false report "WARNING: c_mux_bit_v12_0_3_viv: Only synchronous controls will be passed to the pipeline registers." & CR &
          "Both asynchronous and synchronous controls will be implemented on the final output register"
          severity warning;
      end if;
    end if;

    return 0;
  end function check_generics;
  
  FUNCTION fn_stretch_string(p_char : STRING; p_len : INTEGER) RETURN STRING IS
    VARIABLE ret_val : STRING(1 TO p_len);
  BEGIN
    FOR i IN 1 TO p_len LOOP
      ret_val(i) := p_char(1);
    END LOOP;
    RETURN ret_val;
  END fn_stretch_string;
  
END c_mux_bit_v12_0_3_pkg;


-- $Id: c_mux_bit_pipereg.vhd,v 1.3 2009/09/08 15:11:45 akennedy Exp $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Describes a register optimised for particular mux generic conditions
-- Instantiates the c_reg_fd_v12_0_3 BaseBlock with particular sets of generics
-- Synchronous controls are implemented in the mux datapath and not by the REGISTER
-- BaseBlock, so the CE signal is modified in some cases to allow synchronous
-- controls that are implemented in the LUTs to be registered when they occur.
-------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

LIBRARY xbip_utils_v3_0_7;
USE xbip_utils_v3_0_7.xbip_utils_v3_0_7_pkg.ALL;

LIBRARY c_reg_fd_v12_0_3;
USE c_reg_fd_v12_0_3.c_reg_fd_v12_0_3_viv_comp.ALL;

ENTITY c_mux_bit_pipereg IS
  GENERIC (
    c_mux_inputs         : INTEGER;  -- number of inputs to the mux to determine o/p reg style
    c_use_reg_sync_ctrls : BOOLEAN;  -- allows use of component for the o/p reg too
    c_pipe_width         : INTEGER;  -- width of the pipeline register (or o/p register)
    c_ainit_val          : STRING;
    c_sinit_val          : STRING;
    c_sync_enable        : INTEGER;
    c_sync_priority      : INTEGER;
    c_has_ce             : INTEGER;
    c_has_aclr           : INTEGER;
    c_has_aset           : INTEGER;
    c_has_sclr           : INTEGER;
    c_has_sset           : INTEGER);
  PORT (
    d    : IN  STD_LOGIC_VECTOR(c_pipe_width-1 DOWNTO 0);
    clk  : IN  STD_LOGIC;
    ce   : IN  STD_LOGIC;
    aclr : IN  STD_LOGIC;
    aset : IN  STD_LOGIC;
    sclr : IN  STD_LOGIC;
    sset : IN  STD_LOGIC;
    q    : OUT STD_LOGIC_VECTOR(c_pipe_width-1 DOWNTO 0));
END ENTITY c_mux_bit_pipereg;

ARCHITECTURE struct OF c_mux_bit_pipereg IS

  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of struct : architecture is "yes";


  -- assign local constants for the converted generic types and call conversion functions  
  CONSTANT enum_c_sync_enable   : T_SYNC_ENABLE  := fn_select_sync_enable(c_sync_enable);

  -- Internal CE signal for registers
  SIGNAL ce_i : STD_LOGIC;
  
  -- Special CE signal (modified CE) for the output registers for the case where the sync
  -- controls are implemented in the mux.  In this case, when an sclr or sset
  -- signal is asserted, we require the CE to also be asserted (when necessary)
  -- to allow the register to clock in the sclr or sset data
  SIGNAL mod_ce : STD_LOGIC := '0';
  
BEGIN  -- ARCHITECTURE struct

  -------------------------------------------------------------------------
  -- CE Generation
  -------------------------------------------------------------------------
  
  gen_ce : IF c_has_ce /= 0 GENERATE
    ce_i <= ce;
  END GENERATE gen_ce;
  gen_no_ce : IF c_has_ce = 0 GENERATE
    ce_i <= '1';
  END GENERATE gen_no_ce;

  sync_over_ce : IF enum_c_sync_enable = SYNC_OVERRIDES_CE GENERATE
    gen_only_sclr : IF c_has_sclr /= 0 AND c_has_sset = 0 GENERATE
      mod_ce <= ce_i OR sclr;
    END GENERATE gen_only_sclr;
    gen_only_sset : IF c_has_sclr = 0 AND c_has_sset /= 0 GENERATE
      mod_ce <= ce_i OR sset;
    END GENERATE gen_only_sset;
    gen_sclr_sset : IF c_has_sclr /= 0 AND c_has_sset /= 0 GENERATE
      mod_ce <= ce_i OR sclr OR sset;
    END GENERATE gen_sclr_sset;
    gen_ce_only : IF c_has_sclr = 0 AND c_has_sset = 0 GENERATE
      mod_ce <= ce_i;
    END GENERATE gen_ce_only;
  END GENERATE sync_over_ce;

  ce_over_sync : IF enum_c_sync_enable = CE_OVERRIDES_SYNC GENERATE
    mod_ce <= ce_i;
  END GENERATE ce_over_sync;
    
  -----------------------------------------------------------------------------
  -- Pipeline register instantiations
  -----------------------------------------------------------------------------
  gen_pipeline_reg : IF c_pipe_width /= 1 GENERATE
    gen_only_sync_ctrls : IF (c_has_sclr = 0 XOR c_has_sset = 0) GENERATE
      -- Implement the control on the primitive
      pipe_reg : c_reg_fd_v12_0_3_viv
        GENERIC MAP(
          c_width         => c_pipe_width,    -- data + sel lines
          c_ainit_val     => c_ainit_val,
          c_sinit_val     => c_sinit_val,
          c_sync_priority => 1,         -- RESET_OVERRIDES_SET
          c_sync_enable   => c_sync_enable,     
          c_has_ce        => c_has_ce,
          c_has_aclr      => 0,
          c_has_aset      => 0,
          c_has_ainit     => 0,
          c_has_sclr      => c_has_sclr,
          c_has_sset      => c_has_sset,
          c_has_sinit     => 0,
          c_enable_rlocs  => 0
          )
        PORT MAP(
          clk   => clk,
          ce    => ce, 
          ainit => '0',
          aclr  => '0',
          aset  => '0',
          sinit => '0',
          sclr  => sclr,
          sset  => sset,
          d     => d,
          q     => q
          );                
    END GENERATE gen_only_sync_ctrls;
    gen_sync_ctrls_with_priority : IF c_has_sclr /= 0 AND c_has_sset /= 0 GENERATE
        pipe_reg : c_reg_fd_v12_0_3_viv
          GENERIC MAP(
            c_width         => c_pipe_width,  -- data + sel lines
            c_ainit_val     => c_ainit_val,
            c_sinit_val     => c_sinit_val,
            c_sync_priority => c_sync_priority,       -- RESET_OVERRIDES_SET
            c_sync_enable   => c_sync_enable,       
            c_has_ce        => c_has_ce,
            c_has_aclr      => 0,
            c_has_aset      => 0,
            c_has_ainit     => 0,
            c_has_sclr      => c_has_sclr,
            c_has_sset      => c_has_sset,
            c_has_sinit     => 0,
            c_enable_rlocs  => 0
            )
          PORT MAP(
            clk   => clk,
            ce    => ce, 
            ainit => '0',
            aclr  => '0',
            aset  => '0',
            sinit => '0',
            sclr  => sclr,
            sset  => sset,
            d     => d,
            q     => q
            );                    
    END GENERATE gen_sync_ctrls_with_priority;
    gen_with_async_ctrls : IF (c_has_sclr = 0 AND c_has_sset = 0) GENERATE
      -- No sync controls exist - implement the async controls on the primtive
      pipe_reg : c_reg_fd_v12_0_3_viv
        GENERIC MAP(
          c_width         => c_pipe_width,    -- data + sel lines
          c_ainit_val     => c_ainit_val,
          c_sinit_val     => c_sinit_val,
          c_sync_priority => 1,         -- RESET_OVERRIDES_SET
          c_sync_enable   => 0,         -- SYNC_OVERRIDES_CE
          c_has_ce        => c_has_ce,
          c_has_aclr      => c_has_aclr,
          c_has_aset      => c_has_aset,
          c_has_ainit     => 0,
          c_has_sclr      => 0,
          c_has_sset      => 0,
          c_has_sinit     => 0,
          c_enable_rlocs  => 0
          )
        PORT MAP(
          clk   => clk,
          ce    => ce,              
          ainit => '0',
          aclr  => aclr,
          aset  => aset,
          sinit => '0',
          sclr  => '0',
          sset  => '0',
          d     => d,
          q     => q
          );                
    END GENERATE gen_with_async_ctrls;
  END GENERATE gen_pipeline_reg;

  -----------------------------------------------------------------------------
  -- Output register instantiations
  -----------------------------------------------------------------------------
  gen_output_reg : IF c_pipe_width = 1 GENERATE
    gen_reg_no_sync_ctrls : IF c_use_reg_sync_ctrls = false GENERATE
      -- implement the sync controls in the mux - only async controls on the register
      output_reg : c_reg_fd_v12_0_3_viv
        GENERIC MAP(
          c_width         => 1,         -- bit mux o/p is only ever 1 bit wide
          c_ainit_val     => c_ainit_val,
          c_sinit_val     => c_sinit_val,
          c_sync_priority => 1,         -- RESET_OVERRIDES_SET
          c_sync_enable   => 0,         -- SYNC_OVERRIDES_CE
          c_has_ce        => c_has_ce,
          c_has_aclr      => c_has_aclr,
          c_has_aset      => c_has_aset,
          c_has_ainit     => 0,
          c_has_sclr      => c_has_sclr,
          c_has_sset      => c_has_sset,
          c_has_sinit     => 0,
          c_enable_rlocs  => 0
          )
        PORT MAP(
          clk   => clk,
          ce    => mod_ce,              -- use the modified CE as the sync controls are in the mux LUTs
          ainit => '0',
          aclr  => aclr,
          aset  => aset,
          sinit => '0',
          sclr  => '0',
          sset  => '0',
          d(0)  => d(0),
          q(0)  => q(0)
          );  
    END GENERATE gen_reg_no_sync_ctrls;

    gen_use_reg_sync_ctrls : IF c_use_reg_sync_ctrls = true GENERATE
        -- allow the register to implement the sync controls
        output_reg : c_reg_fd_v12_0_3_viv
          GENERIC MAP(
            c_width         => 1,       -- bit mux o/p is only ever 1 bit wide
            c_ainit_val     => c_ainit_val,
            c_sinit_val     => c_sinit_val,
            c_sync_priority => c_sync_priority,
            c_sync_enable   => c_sync_enable,
            c_has_ce        => c_has_ce,
            c_has_aclr      => c_has_aclr,
            c_has_aset      => c_has_aset,
            c_has_ainit     => 0,
            c_has_sclr      => c_has_sclr,
            c_has_sset      => c_has_sset,
            c_has_sinit     => 0,
            c_enable_rlocs  => 0
            )
          PORT MAP(
            clk   => clk,
            ce    => ce,           
            ainit => '0',
            aclr  => aclr,
            aset  => aset,
            sinit => '0',
            sclr  => sclr,
            sset  => sset,
            d(0)  => d(0),
            q(0)  => q(0)
            );          

    END GENERATE gen_use_reg_sync_ctrls;
  END GENERATE gen_output_reg;

END ARCHITECTURE struct;



-- $Id: c_mux_bit_4to1.vhd,v 1.3 2009/09/08 15:11:45 akennedy Exp $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Describes a 4:1 mux optimised for all main architectures
-- Written in structural code for best optimisation and RTL where possible to
-- allow XST to optimise for a particular architecture.
-------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

LIBRARY xbip_utils_v3_0_7;
USE xbip_utils_v3_0_7.xbip_utils_v3_0_7_pkg.ALL;

LIBRARY unisim;
USE unisim.vcomponents.ALL;

ENTITY c_mux_bit_4to1 IS

  GENERIC (
    pipelined_sub_mux : BOOLEAN := false;
    c_sync_priority   : INTEGER := 1;
    c_sync_enable     : INTEGER := 0;
    c_has_aclr        : INTEGER := 0;
    c_has_aset        : INTEGER := 0;
    c_has_sclr        : INTEGER := 0;
    c_has_sset        : INTEGER := 0);

  PORT (
    data : IN  STD_LOGIC_VECTOR(3 DOWNTO 0) := (OTHERS => '0');
    sel  : IN  STD_LOGIC_VECTOR(1 DOWNTO 0) := (OTHERS => '0');
    sclr : IN  STD_LOGIC                    := '0';
    sset : IN  STD_LOGIC                    := '0';
    o    : OUT STD_LOGIC);

END ENTITY c_mux_bit_4to1;

ARCHITECTURE struct OF c_mux_bit_4to1 IS

  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of struct : architecture is "yes";


  -- assign local constants for the converted generic types and call conversion functions
  CONSTANT enum_c_sync_priority : T_REG_PRIORITY := fn_select_sync_priority(c_sync_priority);
  CONSTANT enum_c_sync_enable   : T_SYNC_ENABLE  := fn_select_sync_enable(c_sync_enable);

  SIGNAL f5_in : STD_LOGIC_VECTOR(1 DOWNTO 0);

BEGIN  -- ARCHITECTURE struct

  gen_pipelined_sub_mux : IF pipelined_sub_mux = true GENERATE

    allow_only_sync_ctrls : IF (c_has_sclr /= 0 AND c_has_sset /= 0) GENERATE
      -- if 'normal' priority, implement ctrls on the primitive
      -- if 'strange' priority, implement ctrls in the mux LUTs
      gen_lut_mux : FOR i IN 0 TO 1 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));
      END GENERATE gen_lut_mux;

        f5_lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => o,
                   I0 => f5_in(0),
                   I1 => f5_in(1),
                   I2 => sel(1));

    END GENERATE allow_only_sync_ctrls;

    gen_rtl_mux : IF (c_has_sclr = 0 XOR c_has_sset = 0) GENERATE
      -- can implement controls on the primitive
      o <= data(to_integer(UNSIGNED(sel)));
    END GENERATE gen_rtl_mux;

    allow_async_ctrls : IF c_has_sclr = 0 AND c_has_sset = 0 GENERATE

      both_async : IF c_has_aclr /= 0 AND c_has_aset /= 0 GENERATE
        -- Use a LUT as the final stage to avoid resource conflict

        gen_lut_mux : FOR i IN 0 TO 1 GENERATE
          lut_mux : LUT3
            GENERIC MAP(init => X"CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0));
        END GENERATE gen_lut_mux;

        lut_mux3 : LUT3                 -- takes the place of an F5 mux
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => o,
                   I0 => f5_in(0),
                   I1 => f5_in(1),
                   I2 => sel(1));
      END GENERATE both_async;

      one_async_or_no_ctrls : IF c_has_aclr = 0 OR c_has_aset = 0 GENERATE
        -- can implement controls on the primitive
        o <= data(to_integer(UNSIGNED(sel)));
      END GENERATE one_async_or_no_ctrls;

    END GENERATE allow_async_ctrls;

  END GENERATE gen_pipelined_sub_mux;

  gen_output_stage_mux : IF pipelined_sub_mux = false GENERATE

    f5_4to1_mux : IF (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                    OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                    OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                    OR (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                    OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                    OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE
      -- We use the 2:1 LUT muxes and the MUXF5 as normal for a 4:1 mux
        o <= data(to_integer(UNSIGNED(sel)));
    END GENERATE f5_4to1_mux;

    f5_with_2to1_mux_en : IF (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                            OR (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset /= 0)
                            OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                            OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset /= 0)
                            OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                            OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE
      -- Build 2x 2:1 LUT muxes and put the sync control (suitably modified)
      -- into the LUTs as an 'enable'
      sclr_only : IF c_has_sclr /= 0 GENERATE
      BEGIN
        gen_lut_mux : FOR i IN 0 TO 1 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"00CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sclr);
        END GENERATE gen_lut_mux;

        f5 : MUXF5
          PORT MAP(O  => o,
                   I0 => f5_in(0),
                   I1 => f5_in(1),
                   S  => sel(1));
      END GENERATE sclr_only;

      sset_only : IF c_has_sset /= 0 GENERATE
      BEGIN
        gen_lut_mux : FOR i IN 0 TO 1 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"FFCA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sset);
        END GENERATE gen_lut_mux;

        f5 : MUXF5
          PORT MAP(O  => o,
                   I0 => f5_in(0),
                   I1 => f5_in(1),
                   S  => sel(1));
      END GENERATE sset_only;

    END GENERATE f5_with_2to1_mux_en;

    lut_muxes_only : IF (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                       OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                       OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                       OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0) GENERATE
      -- Build 3x 2:1 muxes with LUTs and put the sync controls into them -
      -- need to consider the priority of the sync controls and put them into the LUT
      -- muxes in the right order.  The one with the highest priority will be in the
      -- final mux stage
      clr_over_set : IF enum_c_sync_priority = RESET_OVERRIDES_SET GENERATE

        gen_sync_only : IF (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0) GENERATE
          -- can implement controls on the primitive
          o <= data(to_integer(UNSIGNED(sel)));
        END GENERATE gen_sync_only;

        gen_sync_and_others : IF NOT(c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0) GENERATE

          gen_lut_mux : FOR i IN 0 TO 1 GENERATE
            lut_mux : LUT4
              GENERIC MAP(init => X"FFCA")
              PORT MAP(O  => f5_in(i),
                       I0 => data(2*i),
                       I1 => data((2*i)+1),
                       I2 => sel(0),
                       I3 => sset);
          END GENERATE gen_lut_mux;

          lut_mux2 : LUT4
            GENERIC MAP(init => X"00CA")
            PORT MAP(O  => o,
                     I0 => f5_in(0),
                     I1 => f5_in(1),
                     I2 => sel(1),
                     I3 => sclr);
        END GENERATE gen_sync_and_others;

      END GENERATE clr_over_set;

      set_over_clr : IF enum_c_sync_priority = SET_OVERRIDES_RESET GENERATE
        -- priority of controls is not natural to the primitive, so always
        -- implement in the mux

        gen_lut_mux : FOR i IN 0 TO 1 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"00CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sclr);
        END GENERATE gen_lut_mux;

        lut_mux2 : LUT4
          GENERIC MAP(init => X"FFCA")
          PORT MAP(O  => o,
                   I0 => f5_in(0),
                   I1 => f5_in(1),
                   I2 => sel(1),
                   I3 => sset);
      END GENERATE set_over_clr;
    END GENERATE lut_muxes_only;
  END GENERATE gen_output_stage_mux;

END ARCHITECTURE struct;



-- $Id: c_mux_bit_8to1.vhd,v 1.3 2009/09/08 15:11:45 akennedy Exp $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Describes an 8:1 mux optimised for all main architectures
-- Written in structural code for best optimisation and RTL where possible to
-- allow XST to optimise for a particular architecture.
-------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

LIBRARY xbip_utils_v3_0_7;
USE xbip_utils_v3_0_7.xbip_utils_v3_0_7_pkg.ALL;

LIBRARY unisim;
USE unisim.vcomponents.ALL;

ENTITY c_mux_bit_8to1 IS
  GENERIC (
    pipelined_sub_mux : BOOLEAN := false;
    c_sync_priority   : INTEGER := 1;
    c_sync_enable     : INTEGER := 0;
    c_has_aclr        : INTEGER := 0;
    c_has_aset        : INTEGER := 0;
    c_has_sclr        : INTEGER := 0;
    c_has_sset        : INTEGER := 0);
  PORT (
    data : IN  STD_LOGIC_VECTOR(7 DOWNTO 0) := (OTHERS => '0');
    sel  : IN  STD_LOGIC_VECTOR(2 DOWNTO 0) := (OTHERS => '0');
    sclr : IN  STD_LOGIC                    := '0';
    sset : IN  STD_LOGIC                    := '0';
    o    : OUT STD_LOGIC);
END ENTITY c_mux_bit_8to1;

ARCHITECTURE struct OF c_mux_bit_8to1 IS

  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of struct : architecture is "yes";


  -- assign local constants for the converted generic types and call conversion functions
  CONSTANT enum_c_sync_priority : T_REG_PRIORITY := fn_select_sync_priority(c_sync_priority);
  CONSTANT enum_c_sync_enable   : T_SYNC_ENABLE  := fn_select_sync_enable(c_sync_enable);

  SIGNAL f5_in : STD_LOGIC_VECTOR(3 DOWNTO 0);
  SIGNAL f6_in : STD_LOGIC_VECTOR(1 DOWNTO 0);

BEGIN  -- ARCHITECTURE struct

  gen_pipelined_sub_mux : IF pipelined_sub_mux = true GENERATE
    allow_only_sync_ctrls : IF c_has_sclr /= 0 AND c_has_sset /= 0 GENERATE
      -- if 'normal' priority, implement ctrls on the primitive
      -- if 'strange' priority, implement ctrls in the mux LUTs

      gen_lut_mux : FOR i IN 0 TO 3 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));
      END GENERATE gen_lut_mux;

      gen_f5 : FOR i IN 0 TO 1 GENERATE
        f50 : MUXF5
          PORT MAP (
            O  => f6_in(i),
            I0 => f5_in(2*i),
            I1 => f5_in((2*i)+1),
            S  => sel(1));
      END GENERATE gen_f5;

        f6_lut_mux : LUT3                 -- takes the place of an F6 mux
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => o,
                   I0 => f6_in(0),
                   I1 => f6_in(1),
                   I2 => sel(2));

    END GENERATE allow_only_sync_ctrls;

    gen_rtl_mux : IF (c_has_sclr = 0 XOR c_has_sset = 0) GENERATE
      -- can implement controls on the primitive
      o <= data(to_integer(UNSIGNED(sel)));
    END GENERATE gen_rtl_mux;

    allow_async_ctrls : IF c_has_sclr = 0 AND c_has_sset = 0 GENERATE

      both_async : IF c_has_aclr /= 0 AND c_has_aset /= 0 GENERATE
        -- Use a LUT as the final stage to avoid resource conflict

        gen_lut_mux : FOR i IN 0 TO 3 GENERATE
          lut_mux : LUT3
            GENERIC MAP(init => X"CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0));
        END GENERATE gen_lut_mux;

        gen_f5 : FOR i IN 0 TO 1 GENERATE
          f50 : MUXF5
            PORT MAP (
              O  => f6_in(i),
              I0 => f5_in(2*i),
              I1 => f5_in((2*i)+1),
              S  => sel(1));
        END GENERATE gen_f5;

        lut_mux3 : LUT3                 -- takes the place of an F6 mux
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => o,
                   I0 => f6_in(0),
                   I1 => f6_in(1),
                   I2 => sel(2));
      END GENERATE both_async;

      one_async_or_no_ctrls : IF c_has_aclr = 0 OR c_has_aset = 0 GENERATE
        -- can implement controls on the primitive
        o <= data(to_integer(UNSIGNED(sel)));
      END GENERATE one_async_or_no_ctrls;

    END GENERATE allow_async_ctrls;

  END GENERATE gen_pipelined_sub_mux;

  gen_output_stage_mux : IF pipelined_sub_mux = false GENERATE
    -- Can implement control on the primitive, so let XST optimise the mux
    f6_8to1_mux : IF (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                    OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                    OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                    OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                    OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE
        o <= data(to_integer(UNSIGNED(sel)));
    END GENERATE f6_8to1_mux;

    -- Will get a resource conflict if we put the F6 and register in the same
    -- slice, so use a LUT as the final stage of the mux
    more_than_2_ctrls : IF (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset = 0) GENERATE

      gen_lut_mux : FOR i IN 0 TO 3 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));
      END GENERATE gen_lut_mux;

      gen_f5 : FOR i IN 0 TO 1 GENERATE
        f50 : MUXF5
          PORT MAP (
            O  => f6_in(i),
            I0 => f5_in(2*i),
            I1 => f5_in((2*i)+1),
            S  => sel(1));
      END GENERATE gen_f5;

      lut_mux4 : LUT3                   -- takes the place of an F6 mux
        GENERIC MAP(init => X"CA")
        PORT MAP(O  => o,
                 I0 => f6_in(0),
                 I1 => f6_in(1),
                 I2 => sel(2));
    END GENERATE more_than_2_ctrls;

    aclr_or_aset_sclr_or_sset : IF (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                 OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset /= 0)
                                 OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                 OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE

      -- MUXF6 common to all implementations
      f6mux : MUXF6
        PORT MAP (
          O  => o,
          I0 => f6_in(0),
          I1 => f6_in(1),
          S  => sel(2));

      gen_f5 : FOR i IN 0 TO 1 GENERATE
        f5 : MUXF5
          PORT MAP(O  => f6_in(i),
                   I0 => f5_in(2*i),
                   I1 => f5_in((2*i)+1),
                   S  => sel(1));
      END GENERATE gen_f5;

      sclr_only : IF c_has_sclr /= 0 GENERATE
        gen_lut_mux : FOR i IN 0 TO 3 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"00CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sclr);
        END GENERATE gen_lut_mux;
      END GENERATE sclr_only;

      sset_only : IF c_has_sset /= 0 GENERATE
        gen_lut_mux : FOR i IN 0 TO 3 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"FFCA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sset);
        END GENERATE gen_lut_mux;
      END GENERATE sset_only;

    END GENERATE aclr_or_aset_sclr_or_sset;

    aclr_and_aset_sclr_or_sset : IF (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                   OR (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE
    -- Have only 1 sync control and 2 async controls - put it in a LUT mux and then we can use the
    -- register in the same slice - can't use the F6 as there would be a resource conflict for the BY input

      -- Common code
      gen_lut_mux : FOR i IN 0 TO 3 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));
      END GENERATE gen_lut_mux;

      gen_f5 : FOR i IN 0 TO 1 GENERATE
        f5 : MUXF5
          PORT MAP(O  => f6_in(i),
                   I0 => f5_in(2*i),
                   I1 => f5_in((2*i)+1),
                   S  => sel(1));
      END GENERATE gen_f5;

      sclr_only : IF c_has_sclr /= 0 GENERATE
        lut_mux4 : LUT4                 -- takes the place of an F6 mux
          GENERIC MAP(init => X"00CA")
          PORT MAP(O  => o,
                   I0 => f6_in(0),
                   I1 => f6_in(1),
                   I2 => sel(2),
                   I3 => sclr);
      END GENERATE sclr_only;

      sset_only : IF c_has_sset /= 0 GENERATE
        lut_mux4 : LUT4                 -- takes the place of an F6 mux
          GENERIC MAP(init => X"FFCA")
          PORT MAP(O  => o,
                   I0 => f6_in(0),
                   I1 => f6_in(1),
                   I2 => sel(2),
                   I3 => sset);
      END GENERATE sset_only;

    END GENERATE aclr_and_aset_sclr_or_sset;

    -- We have 2 sync controls, so put them both in LUT muxes and allow use of
    -- the register in the final slice by making the output of the mux a LUT
    -- When we have both sync controls and no async controls, do them in the
    -- muxes rather than passing to register as we can do the priorities nicer in
    -- the muxes
    lut_muxes_2_sync_ctrls : IF (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                               OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                               OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                               OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0) GENERATE

      -- MUXF5 common to both implementations
        gen_f5 : FOR i IN 0 TO 1 GENERATE
          f5 : MUXF5
            PORT MAP (
              O  => f6_in(i),
              I0 => f5_in(2*i),
              I1 => f5_in((2*i)+1),
              S  => sel(1));
        END GENERATE gen_f5;

      clr_over_set : IF enum_c_sync_priority = RESET_OVERRIDES_SET GENERATE

        gen_lut_mux : FOR i IN 0 TO 3 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"FFCA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sset);
        END GENERATE gen_lut_mux;

        lut_mux4 : LUT4                 -- takes the place of an F6 mux
          GENERIC MAP(init => X"00CA")
          PORT MAP(O  => o,
                   I0 => f6_in(0),
                   I1 => f6_in(1),
                   I2 => sel(2),
                   I3 => sclr);
      END GENERATE clr_over_set;

      set_over_clr : IF enum_c_sync_priority = SET_OVERRIDES_RESET GENERATE

        gen_lut_mux : FOR i IN 0 TO 3 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"00CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sclr);
        END GENERATE gen_lut_mux;

        lut_mux4 : LUT4                 -- takes the place of an F6 mux
          GENERIC MAP(init => X"FFCA")
          PORT MAP(O  => o,
                   I0 => f6_in(0),
                   I1 => f6_in(1),
                   I2 => sel(2),
                   I3 => sset);
      END GENERATE set_over_clr;

    END GENERATE lut_muxes_2_sync_ctrls;
  END GENERATE gen_output_stage_mux;

END ARCHITECTURE struct;



-- $Id: c_mux_bit_16to1.vhd,v 1.3 2009/09/08 15:11:45 akennedy Exp $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Describes a 16:1 mux optimised for all main architectures
-- Written in structural code for best optimisation and RTL where possible to
-- allow XST to optimise for a particular architecture.
-------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

LIBRARY xbip_utils_v3_0_7;
USE xbip_utils_v3_0_7.xbip_utils_v3_0_7_pkg.ALL;

LIBRARY unisim;
USE unisim.vcomponents.ALL;

ENTITY c_mux_bit_16to1 IS
  GENERIC (
    pipelined_sub_mux : BOOLEAN         := false;
    c_xdevicefamily   : string          := "no_family";
    c_sync_priority   : INTEGER         := 1;
    c_sync_enable     : INTEGER         := 0;
    c_has_aclr        : INTEGER         := 0;
    c_has_aset        : INTEGER         := 0;
    c_has_sclr        : INTEGER         := 0;
    c_has_sset        : INTEGER         := 0);
  PORT (
    data : IN  STD_LOGIC_VECTOR(15 DOWNTO 0) := (OTHERS => '0');
    sel  : IN  STD_LOGIC_VECTOR(3 DOWNTO 0)  := (OTHERS => '0');
    sclr : IN  STD_LOGIC                     := '0';
    sset : IN  STD_LOGIC                     := '0';
    o    : OUT STD_LOGIC);
END ENTITY c_mux_bit_16to1;

ARCHITECTURE struct OF c_mux_bit_16to1 IS

  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of struct : architecture is "yes";


  -- assign local constants for the converted generic types and call conversion functions
  CONSTANT enum_c_sync_priority : T_REG_PRIORITY := fn_select_sync_priority(c_sync_priority);
  CONSTANT enum_c_sync_enable   : T_SYNC_ENABLE  := fn_select_sync_enable(c_sync_enable);

  SIGNAL f5_in : STD_LOGIC_VECTOR(7 DOWNTO 0);
  SIGNAL f6_in : STD_LOGIC_VECTOR(3 DOWNTO 0);
  SIGNAL f7_in : STD_LOGIC_VECTOR(1 DOWNTO 0);

BEGIN  -- ARCHITECTURE struct

  gen_pipelined_sub_mux : IF pipelined_sub_mux = true GENERATE
    allow_only_sync_ctrls : IF (c_has_sclr /= 0 AND c_has_sset /= 0) GENERATE
      -- if 'normal' priority, implement ctrls on the primitive
      -- if 'strange' priority, implement ctrls in the mux LUTs
      gen_lut_mux : FOR i IN 0 TO 7 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));
      END GENERATE gen_lut_mux;

      f5_gen : FOR i IN 0 TO 3 GENERATE
        f5 : MUXF5
          PORT MAP(O  => f6_in(i),
                   I0 => f5_in(2*i),
                   I1 => f5_in((2*i)+1),
                   S  => sel(1));
      END GENERATE f5_gen;

      f6_gen : FOR i IN 0 TO 1 GENERATE
        f6 : MUXF6
          PORT MAP(O  => f7_in(i),
                   I0 => f6_in(2*i),
                   I1 => f6_in((2*i)+1),
                   S  => sel(2));
      END GENERATE f6_gen;

      f7_lut_mux : LUT3                 -- takes the place of an F7 mux
        GENERIC MAP(init => X"CA")
        PORT MAP(O  => o,
                 I0 => f7_in(0),
                 I1 => f7_in(1),
                 I2 => sel(3));

    END GENERATE allow_only_sync_ctrls;

    gen_rtl_mux : IF (c_has_sclr = 0 XOR c_has_sset = 0) GENERATE
      -- can implement controls on the primitive
      o <= data(to_integer(UNSIGNED(sel)));
    END GENERATE gen_rtl_mux;

    allow_async_ctrls : IF c_has_sclr = 0 AND c_has_sset = 0 GENERATE

      both_async : IF c_has_aclr /= 0 AND c_has_aset /= 0 GENERATE
        -- Use a LUT as the final stage to avoid resource conflict
        gen_lut_mux : FOR i IN 0 TO 7 GENERATE
          lut_mux : LUT3
            GENERIC MAP(init => X"CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0));
        END GENERATE gen_lut_mux;

        f5_gen : FOR i IN 0 TO 3 GENERATE
          f5 : MUXF5
            PORT MAP(O  => f6_in(i),
                     I0 => f5_in(2*i),
                     I1 => f5_in((2*i)+1),
                     S  => sel(1));
        END GENERATE f5_gen;

        f6_gen : FOR i IN 0 TO 1 GENERATE
          f6 : MUXF6
            PORT MAP(O  => f7_in(i),
                     I0 => f6_in(2*i),
                     I1 => f6_in((2*i)+1),
                     S  => sel(2));
        END GENERATE f6_gen;

        f7_lut_mux : LUT3               -- takes the place of an F7 mux
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => o,
                   I0 => f7_in(0),
                   I1 => f7_in(1),
                   I2 => sel(3));
      END GENERATE both_async;

      one_async_or_no_ctrls : IF c_has_aclr = 0 OR c_has_aset = 0 GENERATE
        -- can implement controls on the primitive
        o <= data(to_integer(UNSIGNED(sel)));
      END GENERATE one_async_or_no_ctrls;

    END GENERATE allow_async_ctrls;

  END GENERATE gen_pipelined_sub_mux;

  gen_output_stage_mux : IF pipelined_sub_mux = false GENERATE
    -- can implement controls on primitive without any resource conflicts
    f7_16to1_mux : IF ((c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                       OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                       OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                       OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                       OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset /= 0)) GENERATE
      mux : PROCESS (data, sel) IS
      BEGIN
        o <= data(to_integer(UNSIGNED(sel)));
      END PROCESS mux;
    END GENERATE f7_16to1_mux;

    both_async_no_sync : IF c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset = 0 GENERATE

      gen_lut_mux : FOR i IN 0 TO 7 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));
      END GENERATE gen_lut_mux;
      gen_f5 : FOR i IN 0 TO 3 GENERATE
        f5 : MUXF5
          PORT MAP(O  => f6_in(i),
                   I0 => f5_in(2*i),
                   I1 => f5_in((2*i)+1),
                   S  => sel(1));
      END GENERATE gen_f5;
      gen_f6 : FOR i IN 0 TO 1 GENERATE
        f6 : MUXF6
          PORT MAP(O  => f7_in(i),
                   I0 => f6_in(2*i),
                   I1 => f6_in((2*i)+1),
                   S  => sel(2));
      END GENERATE gen_f6;
      f7_lut_mux : LUT3                 -- takes the place of an F7 mux
        GENERIC MAP(init => X"CA")
        PORT MAP(O  => o,
                 I0 => f7_in(0),
                 I1 => f7_in(1),
                 I2 => sel(3));
    END GENERATE both_async_no_sync;

    aclr_or_aset_sclr_or_sset : IF (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                  OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset /= 0)
                                  OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                  OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE

      -- Common MUXF5 and MUXF6 code for all implementations
      gen_f5 : FOR i IN 0 TO 3 GENERATE
        f5 : MUXF5
          PORT MAP(O  => f6_in(i),
                   I0 => f5_in(2*i),
                   I1 => f5_in((2*i)+1),
                   S  => sel(1));
      END GENERATE gen_f5;

      gen_f6 : FOR i IN 0 TO 1 GENERATE
        f60 : MUXF6
          PORT MAP(O  => f7_in(i),
                   I0 => f6_in(2*i),
                   I1 => f6_in((2*i)+1),
                   S  => sel(2));
      END GENERATE gen_f6;

      gen_v4_v2_s3 : IF has_f7mux(c_xdevicefamily) and has_LUT4(c_xdevicefamily) GENERATE
        -- we can pack more into the slices (use 4 slices rather than 5) by
        -- using the MUXF7 here as there will be no resource conflicts - we do
        -- the sync control in the first stage of LUTs
        sclr_only : IF c_has_sclr /= 0 GENERATE
          gen_lut_mux : FOR i IN 0 TO 7 GENERATE
            lut_mux : LUT4
              GENERIC MAP(init => X"00CA")
              PORT MAP(O  => f5_in(i),
                       I0 => data(2*i),
                       I1 => data((2*i)+1),
                       I2 => sel(0),
                       I3 => sclr);
          END GENERATE gen_lut_mux;
        END GENERATE sclr_only;
        sset_only : IF c_has_sset /= 0 GENERATE
          gen_lut_mux : FOR i IN 0 TO 7 GENERATE
            lut_mux : LUT4
              GENERIC MAP(init => X"FFCA")
              PORT MAP(O  => f5_in(i),
                       I0 => data(2*i),
                       I1 => data((2*i)+1),
                       I2 => sel(0),
                       I3 => sset);
          END GENERATE gen_lut_mux;
        END GENERATE sset_only;

        f7mux : MUXF7
          PORT MAP (
            O  => o,
            I0 => f7_in(0),
            I1 => f7_in(1),
            S  => sel(3));

      END GENERATE gen_v4_v2_s3;

      gen_v_s2 : IF not(has_f7mux(c_xdevicefamily)) GENERATE
        -- MUXF7 primitive doesn't exist, so we use a LUT and do the sync
        -- control in the final stage
        gen_lut_mux : FOR i IN 0 TO 7 GENERATE
          lut_mux : LUT3
            GENERIC MAP(init => X"CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0));
        END GENERATE gen_lut_mux;

        sclr_only : IF c_has_sclr /= 0 GENERATE
          f7_lut_mux : LUT4
            GENERIC MAP (
              init => X"00CA")
            PORT MAP(O  => o,
                     I0 => f7_in(0),
                     I1 => f7_in(1),
                     I2 => sel(3),
                     I3 => sclr);
        END GENERATE sclr_only;

        sset_only : IF c_has_sset /= 0 GENERATE
          f7_lut_mux : LUT4
            GENERIC MAP (
              init => X"FFCA")
            PORT MAP(O  => o,
                     I0 => f7_in(0),
                     I1 => f7_in(1),
                     I2 => sel(3),
                     I3 => sset);
        END GENERATE sset_only;

      END GENERATE gen_v_s2;

    END GENERATE aclr_or_aset_sclr_or_sset;

    aclr_and_set_sclr_or_sset : IF (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                  OR (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE

      gen_lut_mux : FOR i IN 0 TO 7 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));
      END GENERATE gen_lut_mux;

      gen_f5 : FOR i IN 0 TO 3 GENERATE
        f5 : MUXF5
          PORT MAP(O  => f6_in(i),
                   I0 => f5_in(2*i),
                   I1 => f5_in((2*i)+1),
                   S  => sel(1));
      END GENERATE gen_f5;

      gen_f6 : FOR i IN 0 TO 1 GENERATE
        f60 : MUXF6
          PORT MAP(O  => f7_in(i),
                   I0 => f6_in(2*i),
                   I1 => f6_in((2*i)+1),
                   S  => sel(2));
      END GENERATE gen_f6;

      sclr_only : IF c_has_sclr /= 0 GENERATE
        f7_lut_mux : LUT4
          GENERIC MAP (
            init => X"00CA")
          PORT MAP(O  => o,
                   I0 => f7_in(0),
                   I1 => f7_in(1),
                   I2 => sel(3),
                   I3 => sclr);
      END GENERATE sclr_only;

      sset_only : IF c_has_sset /= 0 GENERATE
        f7_lut_mux : LUT4
          GENERIC MAP (
            init => X"FFCA")
          PORT MAP(O  => o,
                   I0 => f7_in(0),
                   I1 => f7_in(1),
                   I2 => sel(3),
                   I3 => sset);
      END GENERATE sset_only;

    END GENERATE aclr_and_set_sclr_or_sset;

    aclr_or_aset_sclr_and_sset : IF ((c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                                     OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                                     OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                                     OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)) GENERATE

                                        -- Common code for MUXF5s and MUXF6s for both variations
      gen_f5 : FOR i IN 0 TO 3 GENERATE
        f5 : MUXF5
          PORT MAP(O  => f6_in(i),
                   I0 => f5_in(2*i),
                   I1 => f5_in((2*i)+1),
                   S  => sel(1));
      END GENERATE gen_f5;

      gen_f6 : FOR i IN 0 TO 1 GENERATE
        f6 : MUXF6
          PORT MAP(O  => f7_in(i),
                   I0 => f6_in(2*i),
                   I1 => f6_in((2*i)+1),
                   S  => sel(2));
      END GENERATE gen_f6;

      clr_over_set : IF enum_c_sync_priority = RESET_OVERRIDES_SET GENERATE

        gen_lut_mux : FOR i IN 0 TO 7 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"FFCA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sset);
        END GENERATE gen_lut_mux;

        f7_lut_mux : LUT4               -- takes the place of an F7 mux
          GENERIC MAP(init => X"00CA")
          PORT MAP(O  => o,
                   I0 => f7_in(0),
                   I1 => f7_in(1),
                   I2 => sel(3),
                   I3 => sclr);
      END GENERATE clr_over_set;

      set_over_clr : IF enum_c_sync_priority = SET_OVERRIDES_RESET GENERATE

        gen_lut_mux : FOR i IN 0 TO 7 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"00CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sclr);
        END GENERATE gen_lut_mux;

        f7_lut_mux : LUT4               -- takes the place of an F7 mux
          GENERIC MAP(init => X"FFCA")
          PORT MAP(O  => o,
                   I0 => f7_in(0),
                   I1 => f7_in(1),
                   I2 => sel(3),
                   I3 => sset);
      END GENERATE set_over_clr;

    END GENERATE aclr_or_aset_sclr_and_sset;
  END GENERATE gen_output_stage_mux;

END ARCHITECTURE struct;



-- $Id: c_mux_bit_32to1.vhd,v 1.3 2009/09/08 15:11:45 akennedy Exp $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Describes a 32:1 mux optimised for all main architectures
-- Written in structural code for best optimisation and RTL where possible to
-- allow XST to optimise for a particular architecture.
-- Uses the c_mux_bit_4to1 component.
-------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

LIBRARY xbip_utils_v3_0_7;
USE xbip_utils_v3_0_7.xbip_utils_v3_0_7_pkg.ALL;

LIBRARY c_mux_bit_v12_0_3;
USE c_mux_bit_v12_0_3.c_mux_bit_v12_0_3_pkg.ALL;

LIBRARY unisim;
USE unisim.vcomponents.ALL;

ENTITY c_mux_bit_32to1 IS
  GENERIC (
    c_xdevicefamily : string          := "no_family";
    c_sync_priority : INTEGER         := 1;
    c_sync_enable   : INTEGER         := 0;
    c_has_aclr      : INTEGER         := 0;
    c_has_aset      : INTEGER         := 0;
    c_has_sclr      : INTEGER         := 0;
    c_has_sset      : INTEGER         := 0);
  PORT (
    data : IN  STD_LOGIC_VECTOR(31 DOWNTO 0) := (OTHERS => '0');
    sel  : IN  STD_LOGIC_VECTOR(4 DOWNTO 0)  := (OTHERS => '0');
    sclr : IN  STD_LOGIC                     := '0';
    sset : IN  STD_LOGIC                     := '0';
    o    : OUT STD_LOGIC);
END ENTITY c_mux_bit_32to1;

ARCHITECTURE struct OF c_mux_bit_32to1 IS

  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of struct : architecture is "yes";

  
  -- assign local constants for the converted generic types and call conversion functions
  CONSTANT enum_c_sync_priority : T_REG_PRIORITY := fn_select_sync_priority(c_sync_priority);
  CONSTANT enum_c_sync_enable   : T_SYNC_ENABLE  := fn_select_sync_enable(c_sync_enable);

  SIGNAL f5_in : STD_LOGIC_VECTOR(15 DOWNTO 0);
  SIGNAL f6_in : STD_LOGIC_VECTOR(7 DOWNTO 0);
  SIGNAL f7_in : STD_LOGIC_VECTOR(3 DOWNTO 0);
  SIGNAL f8_in : STD_LOGIC_VECTOR(1 DOWNTO 0);
  
BEGIN  -- ARCHITECTURE struct

  -- No sync controls and only 1 async control (or none), so let XST optimise the RTL itself  
  f8_32to1_mux : IF (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                   OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                   OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset = 0)
                   OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset /= 0)
                   OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset = 0) GENERATE

    mux : PROCESS (data, sel) IS
    BEGIN
      -- XST will optimise for whichever architecture is being targeted
      o <= data(to_integer(UNSIGNED(sel)));
    END PROCESS mux;
  END GENERATE f8_32to1_mux;

  two_async_ctrls_only : IF (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset = 0) GENERATE
    -- should use a LUT as the output for the mux to avoid resource conflict - rest
    -- of the mux uses F7s for the V2 architecture and LUTs for the S2 ARCHITECTURE
  BEGIN
    gen_lut_mux : FOR i IN 0 TO 15 GENERATE
      lut_mux : LUT3
        GENERIC MAP(init => X"CA")
        PORT MAP(O  => f5_in(i),
                 I0 => data(2*i),
                 I1 => data((2*i)+1),
                 I2 => sel(0));      
    END GENERATE gen_lut_mux;

    gen_f5 : FOR i IN 0 TO 7 GENERATE
      f5 : MUXF5
        PORT MAP(O  => f6_in(i),
                 I0 => f5_in(2*i),
                 I1 => f5_in((2*i)+1),
                 S  => sel(1));      
    END GENERATE gen_f5;

    gen_f6 : FOR i IN 0 TO 3 GENERATE
      f6 : MUXF6
        PORT MAP(O  => f7_in(i),
                 I0 => f6_in(2*i),
                 I1 => f6_in((2*i)+1),
                 S  => sel(2));      
    END GENERATE gen_f6;

    v4_v2_s3 : IF has_f7mux(c_xdevicefamily) and has_LUT4(c_xdevicefamily) GENERATE
      gen_f7 : FOR i IN 0 TO 1 GENERATE
        f7mux : MUXF7
          PORT MAP(O  => f8_in(i),
                   I0 => f7_in(2*i),
                   I1 => f7_in((2*i)+1),
                   S  => sel(3));     
      END GENERATE gen_f7;

      f8_lut_mux : LUT3                 -- takes the place of an F8 mux
        GENERIC MAP(init => X"CA")
        PORT MAP(O  => o,
                 I0 => f8_in(0),
                 I1 => f8_in(1),
                 I2 => sel(4));      
    END GENERATE v4_v2_s3;

    v_s2 : IF not(has_f7mux(c_xdevicefamily)) GENERATE
      -- cannot use the F7 or F8 muxes      
      -- implement a 4:1 RTL mux
      mux_4to1 : c_mux_bit_4to1
        GENERIC MAP (
          c_sync_priority => c_sync_priority,
          c_sync_enable   => c_sync_enable,
          c_has_aclr      => 0,
          c_has_aset      => 0,
          c_has_sclr      => 0,
          c_has_sset      => 0)
        PORT MAP (
          data => f7_in,
          sel  => sel(4 DOWNTO 3),
          sclr => '0',
          sset => '0',
          o    => o);       
    END GENERATE v_s2;
    
  END GENERATE two_async_ctrls_only;

  aclr_or_aset_sclr_or_sset : IF (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr = 0 AND c_has_sset /= 0)
                                OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE
    -- Use the MUXF8 and MUXF7 where possible to allow packing into fewer
    -- slices and use of fast mux routing network - implement the sync control
    -- in the first stage of the mux

    -- Common MUXF5 and MUXF6 code for all implementations
    gen_f5 : FOR i IN 0 TO 7 GENERATE
      f5 : MUXF5
        PORT MAP(O  => f6_in(i),
                 I0 => f5_in(2*i),
                 I1 => f5_in((2*i)+1),
                 S  => sel(1));
    END GENERATE gen_f5;

    gen_f6 : FOR i IN 0 TO 3 GENERATE
      f6 : MUXF6
        PORT MAP(O  => f7_in(i),
                 I0 => f6_in(2*i),
                 I1 => f6_in((2*i)+1),
                 S  => sel(2));
    END GENERATE gen_f6;

    v4_v2_s3 : IF has_f7mux(c_xdevicefamily) and has_LUT4(c_xdevicefamily) GENERATE
      sclr_only : IF c_has_sclr /= 0 GENERATE
        gen_lut_mux : FOR i IN 0 TO 15 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"00CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sclr);
        END GENERATE gen_lut_mux;
      END GENERATE sclr_only;

      sset_only : IF c_has_sset /= 0 GENERATE
        gen_lut_mux : FOR i IN 0 TO 15 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"FFCA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sset);
        END GENERATE gen_lut_mux;
      END GENERATE sset_only;

      gen_f7 : FOR i IN 0 TO 1 GENERATE
        f70 : MUXF7
          PORT MAP(O  => f8_in(i),
                   I0 => f7_in(2*i),
                   I1 => f7_in((2*i)+1),
                   S  => sel(3));            
      END GENERATE gen_f7;

      f8mux : MUXF8
        PORT MAP (
          O  => o,
          I0 => f8_in(0),
          I1 => f8_in(1),
          S  => sel(4));
    END GENERATE v4_v2_s3;

    v_s2 : IF not(has_f7mux(c_xdevicefamily)) GENERATE
      gen_lut_mux : FOR i IN 0 TO 15 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));
      END GENERATE gen_lut_mux;

      mux_4to1 : c_mux_bit_4to1
        GENERIC MAP (
          c_sync_priority => c_sync_priority,
          c_sync_enable   => c_sync_enable,
          c_has_aclr      => c_has_aclr,
          c_has_aset      => c_has_aset,
          c_has_sclr      => c_has_sclr,
          c_has_sset      => c_has_sset)
        PORT MAP (
          data => f7_in,
          sel  => sel(4 DOWNTO 3),
          sclr => sclr,
          sset => sset,
          o    => o);
    END GENERATE v_s2;
    
  END GENERATE aclr_or_aset_sclr_or_sset;

  aclr_and_aset_sclr_or_sset : IF (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset = 0)
                                 OR (c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr = 0 AND c_has_sset /= 0) GENERATE
    -- should use a LUT as the output of the mux to avoid resource conflict with the F8
    -- mux - if it the older architectures, use a 4:1 mux component to implement
    -- the controls to avoid using the F7 mux

    gen_lut_mux : FOR i IN 0 TO 15 GENERATE
      lut_mux : LUT3
        GENERIC MAP(init => X"CA")
        PORT MAP(O  => f5_in(i),
                 I0 => data(2*i),
                 I1 => data((2*i)+1),
                 I2 => sel(0));
    END GENERATE gen_lut_mux;

    gen_f5 : FOR i IN 0 TO 7 GENERATE
      f5 : MUXF5
        PORT MAP(O  => f6_in(i),
                 I0 => f5_in(2*i),
                 I1 => f5_in((2*i)+1),
                 S  => sel(1));
    END GENERATE gen_f5;

    gen_f6 : FOR i IN 0 TO 3 GENERATE
      f6 : MUXF6
        PORT MAP(O  => f7_in(i),
                 I0 => f6_in(2*i),
                 I1 => f6_in((2*i)+1),
                 S  => sel(2));
    END GENERATE gen_f6;

    v4_v2_s3 : IF has_f7mux(c_xdevicefamily) and has_LUT4(c_xdevicefamily) GENERATE

      -- Common MUXF7 code for both variants
      gen_f7 : FOR i IN 0 TO 1 GENERATE
        f70 : MUXF7
          PORT MAP(O  => f8_in(i),
                   I0 => f7_in(2*i),
                   I1 => f7_in((2*i)+1),
                   S  => sel(3));            
      END GENERATE gen_f7;

      sclr_only : IF c_has_sclr /= 0 AND c_has_sset = 0 GENERATE        
        f8_lut_mux : LUT4               -- takes the place of an F8 mux
          GENERIC MAP(init => X"00CA")
          PORT MAP(O  => o,
                   I0 => f8_in(0),
                   I1 => f8_in(1),
                   I2 => sel(4),
                   I3 => sclr);        
      END GENERATE sclr_only;

      sset_only : IF c_has_sclr = 0 AND c_has_sset /= 0 GENERATE        
        f8_lut_mux : LUT4               -- takes the place of an F8 mux
          GENERIC MAP(init => X"FFCA")
          PORT MAP(O  => o,
                   I0 => f8_in(0),
                   I1 => f8_in(1),
                   I2 => sel(4),
                   I3 => sset);           
      END GENERATE sset_only;
    END GENERATE v4_v2_s3;

    v_s2 : IF not(has_f7mux(c_xdevicefamily)) GENERATE
      mux_4to1 : c_mux_bit_4to1
        GENERIC MAP (
          c_sync_priority => c_sync_priority,
          c_sync_enable   => c_sync_enable,
          c_has_aclr      => c_has_aclr,
          c_has_aset      => c_has_aset,
          c_has_sclr      => c_has_sclr,
          c_has_sset      => c_has_sset)
        PORT MAP (
          data => f7_in,
          sel  => sel(4 DOWNTO 3),
          sclr => sclr,
          sset => sset,
          o    => o);
    END GENERATE v_s2;
    
  END GENERATE aclr_and_aset_sclr_or_sset;

  two_sync_ctrls : IF ((c_has_aclr /= 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                       OR (c_has_aclr /= 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                       OR (c_has_aclr = 0 AND c_has_aset /= 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)
                       OR (c_has_aclr = 0 AND c_has_aset = 0 AND c_has_sclr /= 0 AND c_has_sset /= 0)) GENERATE
  BEGIN

    gen_f5 : FOR i IN 0 TO 7 GENERATE
      f5 : MUXF5
        PORT MAP(O  => f6_in(i),
                 I0 => f5_in(2*i),
                 I1 => f5_in((2*i)+1),
                 S  => sel(1));  
    END GENERATE gen_f5;

    gen_f6 : FOR i IN 0 TO 3 GENERATE
      f6 : MUXF6
        PORT MAP(O  => f7_in(i),
                 I0 => f6_in(2*i),
                 I1 => f6_in((2*i)+1),
                 S  => sel(2));  
    END GENERATE gen_f6;

    gen_v4_v2_s3 : IF has_f7mux(c_xdevicefamily) and has_LUT4(c_xdevicefamily) GENERATE

      gen_f7 : FOR i IN 0 TO 1 GENERATE
        f7 : MUXF7
          PORT MAP(O  => f8_in(i),
                   I0 => f7_in(2*i),
                   I1 => f7_in((2*i)+1),
                   S  => sel(3));  
      END GENERATE gen_f7;

      clr_over_set : IF enum_c_sync_priority = RESET_OVERRIDES_SET GENERATE

        gen_lut_mux : FOR i IN 0 TO 15 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"FFCA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sset);    
        END GENERATE gen_lut_mux;

        f8_lut_mux : LUT4               -- takes the place of an F8 mux
          GENERIC MAP(init => X"00CA")
          PORT MAP(O  => o,
                   I0 => f8_in(0),
                   I1 => f8_in(1),
                   I2 => sel(4),
                   I3 => sclr);  

      END GENERATE clr_over_set;

      set_over_clr : IF enum_c_sync_priority = SET_OVERRIDES_RESET GENERATE
        
        gen_lut_mux : FOR i IN 0 TO 15 GENERATE
          lut_mux : LUT4
            GENERIC MAP(init => X"00CA")
            PORT MAP(O  => f5_in(i),
                     I0 => data(2*i),
                     I1 => data((2*i)+1),
                     I2 => sel(0),
                     I3 => sclr);    
        END GENERATE gen_lut_mux;

        f8_lut_mux : LUT4               -- takes the place of an F8 mux
          GENERIC MAP(init => X"FFCA")
          PORT MAP(O  => o,
                   I0 => f8_in(0),
                   I1 => f8_in(1),
                   I2 => sel(4),
                   I3 => sset);  

      END GENERATE set_over_clr;
      
    END GENERATE gen_v4_v2_s3;

    gen_v_s2 : IF not(has_f7mux(c_xdevicefamily)) GENERATE
      gen_lut_mux : FOR i IN 0 TO 15 GENERATE
        lut_mux : LUT3
          GENERIC MAP(init => X"CA")
          PORT MAP(O  => f5_in(i),
                   I0 => data(2*i),
                   I1 => data((2*i)+1),
                   I2 => sel(0));    
      END GENERATE gen_lut_mux;

      -- let the 4:1 mux do all the optimisation for sync controls
      -- don't implement them earlier to minimise fan-out on the sync controls
      -- the 4:1 mux also works in all architectures
      mux_4to1 : c_mux_bit_4to1
        GENERIC MAP (
          c_sync_priority => c_sync_priority,
          c_sync_enable   => c_sync_enable,
          c_has_aclr      => c_has_aclr,
          c_has_aset      => c_has_aset,
          c_has_sclr      => c_has_sclr,
          c_has_sset      => c_has_sset)
        PORT MAP (
          data => f7_in,
          sel  => sel(4 DOWNTO 3),
          sclr => sclr,
          sset => sset,
          o    => o);         
    END GENERATE gen_v_s2;
    
  END GENERATE two_sync_ctrls;

END ARCHITECTURE struct;



-- $Id: c_mux_bit_v12_0_3_viv.vhd,v 1.3 2009/09/08 15:11:45 akennedy Exp $
--------------------------------------------------------------------------------
--  (c) Copyright 1995-2005 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
--   ____  ____
--  /   /\/   /
-- /___/  \  /   Vendor: Xilinx
-- \   \   \/    Version: 8.0
--  \   \        Filename: c_mux_bit_v12_0_3_viv.vhd
--  /   /
-- /___/   /\
-- \   \  /  \
--  \___\/\___\
--
-------------------------------------------------------------------------------
--
-- This file implements a bit multiplexer with the following features:
--
-- # Selectable input widths from 2 to 256
-- # Optional registered output (in addition to async output for latency = 1)
-- # Optional pipelining when the mux size is greater than 8:1 (1 stage or 2
--   stages depending on the input width)
-- # Initialisation of the pipeline registers on startup via the ainit value
-- # Control of the pipeline registers via the optional ce and sclr pins
-- # Support for Spartan2, Spartan3, Virtex, Virtex2(Pro) and Virtex4

-- Design notes:
-- The ainit and sinit pins are redundant here and have been kept to maintain the
-- block interface. The sinit value is also redundant. Attemping use of these
-- options will cause an error or warning at compile time. Sinit and ainit
-- functionality can still be achieved at at higher level by using the
-- individual sync or async controls.
--
-- The RTL code will synthesise differently in Spartan2 and Virtex devices than in
-- Virtex2, Virtex4 and Spartan3 devices since only MUXF5 and MUXF6 are supported
-- in the former and MUXF7 and MUXF8 can be used in the newer devices for building
-- larger multiplexers.
--
-- The general technique used is to determine the maximum possible mux width
-- from the width of the select bus specified and expand the input data bus to
-- this width. XST can then determine which inputs will be constant (as they
-- have been initialised to 0) and can optimise away any unnecessary logic.
-- Where an asynchronous output is present, RTL description is used to offer
-- minimum resource usage.
--
-- A different pipelining technique has been used compared to the version 7
-- core. The pipelined sub-muxes are described such that the number of levels
-- of logic in each is equalised or, if possible, the input stage has fewer
-- levels of logic than the other stages. This means that if an asynchronous
-- output is connected to the input of the pipelined mux, the delay to the next
-- register (the first in the pipeline) will be slightly lower. It was felt
-- that the slight increase in resources was justified as the pipelined
-- implementations are likely to be used in designs where speed is more
-- critical than area. The other advantage of reducing the number of input
-- stage logic levels may be to simplify the routing of the input stage into
-- the pipeline registers. These improvements are, however, unlikely to be
-- seen during characterisation as they will require an asynchronous input to
-- the overall multiplexer to test.
--
-- The controls on the pipeline registers have also changed to provide a
-- consistent standard across all the BaseBlox. The registers will now take
-- async or sync controls, but in the case where >= 1 of each type of control is
-- selected, only the sync controls will be passed to the pipeline registers
-- and a warning assertion displayed.
--
-- When the final sub-mux uses an F6, F7 or F8 mux in conjunction with an
-- output register that uses either both sync controls or both async controls,
-- only one control signal can be fed to the register that is in the same slice
-- as the F* mux. This results in the output register being placed in a
-- different slice, incurring a routing delay. If the final part of the final
-- sub-mux is a 2:1 LUT mux however, the register in the same slice can be
-- used giving better performance, assuming that the routing delay to the 2:1
-- mux is low compared to that of the F*-mux-to-output-register routing delay
-- in the previous core version.
--
-- A final trick that is frequently used is the sinking of the synchronous
-- register controls into the LUTs in the mux stages. There is often a spare
-- LUT input that can be used as an 'enable' for the mux, but can equally be
-- used to implement SCLR or SSET. In larger muxes, the priority of these
-- controls can also be dictated by the order that they appear in in the mux
-- hierarchy, hence reducing the logic that must lie in the datapath before the
-- final output register.
--------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Library declarations
-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library xbip_utils_v3_0_7;
use xbip_utils_v3_0_7.xbip_utils_v3_0_7_pkg.all;

library c_mux_bit_v12_0_3;
use c_mux_bit_v12_0_3.c_mux_bit_v12_0_3_pkg.all;

-- Allow instantiation of primitives
library unisim;
use unisim.vcomponents.all;

-------------------------------------------------------------------------------
-- Entity declaration
-------------------------------------------------------------------------------

entity c_mux_bit_v12_0_3_viv is
  generic (
    C_FAMILY        : string  := "virtex2";  -- Specifies device family being targeted
    C_XDEVICEFAMILY : string  := "virtex2";  -- Specifies device family being targeted
    C_INPUTS        : integer := 2;          -- Specifies input data bus width to mux
    C_SEL_WIDTH     : integer := 1;          -- Specifies select bus width
    C_PIPE_STAGES   : integer := 0;          -- Specifies number of pipeline stages in conj. with c_latency (0,1,2)
    C_LATENCY       : integer := 1;          -- Specifies latency of mux (0,1,2,3)
    C_HEIGHT        : integer := 0;          -- Redundant in VHDL core
    C_AINIT_VAL     : string  := "0";        -- Async init value, defaults to 0 in the code, init value for registers
    C_SINIT_VAL     : string  := "0";        -- Sync init value, redundant here
    C_SYNC_ENABLE   : integer := 0;          -- Priority of CE and sync controls - passed to o/p register
    C_SYNC_PRIORITY : integer := 1;          -- Priority of sync set and clear for output register
    C_HAS_O         : integer := 0;          -- Unregistered output
    C_HAS_Q         : integer := 1;          -- Registered output
    C_HAS_CE        : integer := 0;          -- Optional clock enable
    C_HAS_ACLR      : integer := 0;          -- Optional async clear
    C_HAS_ASET      : integer := 0;          -- Optional async set
    C_HAS_AINIT     : integer := 0;          -- Redundant async init - for interface only
    C_HAS_SCLR      : integer := 0;          -- Optional sync clear
    C_HAS_SSET      : integer := 0;          -- Optional sync set
    C_HAS_SINIT     : integer := 0;          -- Redundant sync init - for interface only
    C_ENABLE_RLOCS  : integer := 0           -- Redundant in VHDL core
    );

  port (
    M     : in  std_logic_vector(C_INPUTS-1 downto 0)    := (others => '0');  -- Input vector
    S     : in  std_logic_vector(C_SEL_WIDTH-1 downto 0) := (others => '0');  -- Select pin
    CLK   : in  std_logic                                := '0';              -- Optional clock
    CE    : in  std_logic                                := '1';              -- optional clock enable
    ASET  : in  std_logic                                := '0';              -- Optional asynch set '1'
    ACLR  : in  std_logic                                := '0';              -- Optional asynch clear to '0'
    AINIT : in  std_logic                                := '0';              -- Redundant in this version
    SSET  : in  std_logic                                := '0';              -- Optional synch set to '1'
    SCLR  : in  std_logic                                := '0';              -- Optional synch clear to '0'
    SINIT : in  std_logic                                := '0';              -- Redundant in this version
    O     : out std_logic                                := '0';              -- Output value
    Q     : out std_logic                                := '0'               -- Registered output value
    );

  -- Choose to optimise away equivalent registers for the cases where the mux
  -- vector has constants present in it (e.g. 17:1 pipelined mux)
  attribute EQUIVALENT_REGISTER_REMOVAL                        : string;
  attribute EQUIVALENT_REGISTER_REMOVAL of c_mux_bit_v12_0_3_viv : entity is "YES";

  -- Turn off primitives optimisation as this can be a problem in eariler
  -- Granite builds, resulting in an unexpected (but functionally correct) mux configuration
  attribute OPTIMIZE_PRIMITIVES                        : string;
  attribute OPTIMIZE_PRIMITIVES of c_mux_bit_v12_0_3_viv : entity is "NO";

  -- Force XST to extract muxes from the RTL code
  attribute MUX_EXTRACT                        : string;
  attribute MUX_EXTRACT of c_mux_bit_v12_0_3_viv : entity is "FORCE";

  -- Force XST to implement muxes using the MUXF5, F6, etc. dedicated muxes
  -- rather than trying to use MUXCY-based structures (slower)
  attribute MUX_STYLE                        : string;
  attribute MUX_STYLE of c_mux_bit_v12_0_3_viv : entity is "MUXF";

  -- Force XST to not maintain the hierarchy of components to allow for better
  -- optimisation and packing
  attribute KEEP_HIERARCHY                        : string;
  attribute KEEP_HIERARCHY of c_mux_bit_v12_0_3_viv : entity is "NO";

end entity c_mux_bit_v12_0_3_viv;

-------------------------------------------------------------------------------
-- Architecture rtl - in reality it uses a mix of RTL and structural VHDL
-------------------------------------------------------------------------------

architecture synth of c_mux_bit_v12_0_3_viv is

  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of synth : architecture is "yes";


  constant enum_c_sync_enable   : T_SYNC_ENABLE  := fn_select_sync_enable(c_sync_enable);      -- priority of CE over SCLR/SSET/SINIT
  constant enum_c_sync_priority : T_REG_PRIORITY := fn_select_sync_priority(c_sync_priority);  -- priority of CE over SCLR/SSET/SINIT

  -- Test that the generics are valid and get the device family first of all
  constant check_gens    : integer range 0 to 0 := check_generics(
    p_xdevicefamily => c_xdevicefamily,
    p_inputs        => c_inputs,
    p_sel_width     => c_sel_width,
    p_height        => c_height,
    p_latency       => c_latency,
    p_pipe_stages   => c_pipe_stages,
    p_has_o         => c_has_o,
    p_has_q         => c_has_q,
    p_has_aclr      => c_has_aclr,
    p_has_aset      => c_has_aset,
    p_has_sclr      => c_has_sclr,
    p_has_sset      => c_has_sset,
    p_has_ainit     => c_has_ainit,
    p_has_sinit     => c_has_sinit
    );
  constant device_family : T_DEVICE_FAMILY      := fn_check_family(c_family);

  -- purpose: Determine if the output register for the mux should be allowed to
  -- use its own synchronous controls or if the controls should be implemented in
  -- the muxes to reduce the LUTs in the datapath
  -- true indicates that the o/p register should use sync controls
  -- false indicates that the mux should implement sync controls
  function fn_use_reg_sync_ctrls(enum_c_sync_priority : T_REG_PRIORITY) return boolean is
  begin  -- FUNCTION fn_use_reg_sync_ctrls
    if c_latency = 0 then
      return true;                      -- never use register when latency is 0, so return default value
    elsif c_latency = 1 and c_pipe_stages = 0 then
      if c_inputs = 2 then
        if c_has_o /= 0 and c_has_q /= 0 then
          return true;                  -- Cannot use sync ctrls in muxes due to async output
        else
          if (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset = 0)
            or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset = 0)
            or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset = 0)
            or (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset = 0)
            or (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset /= 0)
            or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset /= 0)
            or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset /= 0)
            or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset /= 0)
            or (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset /= 0)
            or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset = 0) then
            return true;                -- can use primitive controls
          elsif (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset = 0)
            or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset /= 0)
            or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset = 0)
            or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset /= 0)
            or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset = 0)
            or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset /= 0) then
            return false;               -- always implement the sync controls in the muxes now
          end if;
        end if;
      else
        if c_has_o /= 0 and c_has_q /= 0 then
          return true;                  -- Cannot use sync ctrls in muxes due to async output
        else
          if (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset = 0)
            or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset = 0)
            or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset = 0)
            or (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset = 0)
            or (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset /= 0) then
            return true;                -- can use primitive controls
          elsif (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset = 0)
            or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset = 0)
            or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset /= 0)
            or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset = 0)
            or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset /= 0)
            or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset = 0)
            or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset /= 0)
            or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset /= 0)
            or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset /= 0)
            or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset /= 0) then
            return false;               -- always implement the sync controls in the muxes now
          elsif (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset /= 0) then
            if enum_c_sync_priority = RESET_OVERRIDES_SET then
              return true;              -- implement on primitive
            else                        -- SET_OVERRIDES_RESET
              return false;             -- implement in mux
            end if;
          end if;
        end if;
      end if;
    elsif ((c_latency = 1 and c_pipe_stages = 1) or c_latency > 1) then
      if (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset = 0)
        or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset = 0)
        or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset = 0)
        or (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset = 0)
        or (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset /= 0) then
        return true;                    -- can use primitive controls
      elsif (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset = 0)
        or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset = 0)
        or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset /= 0)
        or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset = 0)
        or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr = 0 and c_has_sset /= 0)
        or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset = 0)
        or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr = 0 and c_has_sset /= 0)
        or (c_has_aclr /= 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset /= 0)
        or (c_has_aclr /= 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset /= 0)
        or (c_has_aclr = 0 and c_has_aset /= 0 and c_has_sclr /= 0 and c_has_sset /= 0) then
        return false;                   -- always implement the sync controls in the muxes now
      elsif (c_has_aclr = 0 and c_has_aset = 0 and c_has_sclr /= 0 and c_has_sset /= 0) then
        if enum_c_sync_priority = RESET_OVERRIDES_SET then
          return true;                  -- implement on primitive
        else                            -- SET_OVERRIDES_RESET
          return false;                 -- implement in mux
        end if;
      end if;
    else
      assert false
        report "ERROR                                 : Invalid latency value detected in fn_use_reg_sync_ctrls"
        severity failure;
      return true;
    end if;
    return true; --CR774508 - guarantee return value to mute warning.
  end function fn_use_reg_sync_ctrls;

  -- use_sync_reg_ctrls is assigned in each generate block to indicate if the
  -- sync controls on the output register are required or not (in the case where
  -- the sync controls are implemented in the mux LUTs)
  constant use_reg_sync_ctrls : boolean := fn_use_reg_sync_ctrls(enum_c_sync_priority);

  -- Determine from the select bus width the maximum multiplexer width
  constant max_width : integer range 1 to 256 := 2**c_sel_width;

  -- Create signals to use as the outputs from all multiplexer sizes - use
  -- ainit val to give the registers a startup value
  signal mux_4bit_out  : std_logic_vector(3 downto 0);
  signal mux_8bit_out  : std_logic_vector(7 downto 0);
  signal mux_16bit_out : std_logic_vector(15 downto 0);
  signal mux_32bit_out : std_logic_vector(31 downto 0);
  signal mux_64bit_out : std_logic_vector(63 downto 0);

  -- Internal signal which is the output of the multiplexer
  signal mux_out : std_logic;

  -- SLV of the maximum length addressable by the given select bus width
  -- XST can optimise this down if there are many constants in it
  signal m_ext : std_logic_vector(max_width-1 downto 0);

  -- Input to the final 2:1 LUT mux used when the Fx mux select input would
  -- stop the output register in the same slice being used
  signal lut_mux_in : std_logic_vector(7 downto 0);

  -- Depending on the mux size, a different output vector from the
  -- pipeline registers is required - these SLVs allow this.
  signal pipe_out_6bit  : std_logic_vector(5 downto 0);
  signal pipe_out_11bit : std_logic_vector(10 downto 0);
  signal pipe_out_20bit : std_logic_vector(19 downto 0);
  signal pipe_out_37bit : std_logic_vector(36 downto 0);
  signal pipe_out_70bit : std_logic_vector(69 downto 0);

begin  -- ARCHITECTURE rtl

-------------------------------------------------------------------------------
  -- Extend the m input vector internally to account for all widths
  -- XST then optimises away all the zeros and constant flipflops
  -- Allows lots of flexibility with the mux descriptions.
-------------------------------------------------------------------------------

  m_ext(c_inputs-1 downto 0) <= m;

  fill_msb : if (c_inputs = 9 or c_inputs = 17 or c_inputs = 33 or c_inputs = 65 or c_inputs = 129) generate
    -- Fill spare bits with 'MSB' to allow minimal resource usage
    m_ext(max_width-1 downto c_inputs) <= (others => m(c_inputs-1));
  end generate fill_msb;

  fill_zeros : if (c_inputs /= 9 and c_inputs /= 17 and c_inputs /= 33 and c_inputs /= 65 and c_inputs /= 129) generate
    -- Fill spare bits with '0' to allow logic reduction - better use of slices
    m_ext(max_width-1 downto c_inputs) <= (others => '0');
  end generate fill_zeros;

-------------------------------------------------------------------------------
-- IF/GENERATE for mux sizes including and between 2:1 and 8:1
-------------------------------------------------------------------------------

  gen_2to1_to_8to1_mux : if c_inputs < 9 generate
  begin
    gen_2to1_mux       : if c_inputs = 2 generate

      gen_lat_0 : if c_latency = 0 generate
        mux_out <= m_ext(to_integer(unsigned(s)));
      end generate gen_lat_0;

      gen_lat_1   : if c_latency = 1 generate
        -- If we only have 1 sync control with only a registered output, we can put it in the mux, otherwise
        -- just build an RTL mux and get another LUT in the data path
        sclr_only : if (c_has_aclr /= 0 or c_has_aset /= 0) and c_has_sclr /= 0 and c_has_sset = 0 and c_has_o = 0 generate
          lut_mux : LUT4
            generic map(init => X"00CA")
            port map(O       => mux_out,
                     I0      => m(0),
                     I1      => m(1),
                     I2      => s(0),
                     I3      => sclr);
        end generate sclr_only;
        sset_only : if (c_has_aclr /= 0 or c_has_aset /= 0) and c_has_sclr = 0 and c_has_sset /= 0 and c_has_o = 0 generate
          lut_mux : LUT4
            generic map(init => X"FFCA")
            port map(O       => mux_out,
                     I0      => m(0),
                     I1      => m(1),
                     I2      => s(0),
                     I3      => sset);
        end generate sset_only;

        gen_others : if not((c_has_aclr /= 0 or c_has_aset /= 0) and c_has_sclr /= 0 and c_has_sset = 0 and c_has_o = 0) and
                       not((c_has_aclr /= 0 or c_has_aset /= 0) and c_has_sclr = 0 and c_has_sset /= 0 and c_has_o = 0) generate
          -- we always use the register's sync controls in these cases - special condition in the function controlling which reg to use
          mux_out <= m_ext(to_integer(unsigned(s)));
        end generate gen_others;
      end generate gen_lat_1;
    end generate gen_2to1_mux;

    gen_3to1_or_4to1_mux        : if c_inputs = 3 or c_inputs = 4 generate
      gen_lat_0_or_lat_1_with_o : if c_latency = 0 or (c_latency = 1 and c_has_o /= 0) generate
        -- implement any sync controls (if allowed) on the register
        mux_4to1                : c_mux_bit_4to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => 0,
            c_sync_enable     => 0,
            c_has_aclr        => 0,
            c_has_aset        => 0,
            c_has_sclr        => 0,
            c_has_sset        => 0)
          port map (
            data              => m_ext,
            sel               => s,
            sclr              => '0',
            sset              => '0',
            o                 => mux_out);
      end generate gen_lat_0_or_lat_1_with_o;

      gen_lat_1_no_o : if c_latency = 1 and c_has_o = 0 generate
        -- implement the sync controls in the mux
        mux_4to1     : c_mux_bit_4to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => m_ext,
            sel               => s,
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_lat_1_no_o;
    end generate gen_3to1_or_4to1_mux;

    gen_5to1_to_8to1_mux        : if c_inputs > 4 and c_inputs < 9 generate
      -- implement any sync controls on the register with an extra LUT
      gen_lat_0_or_lat_1_with_o : if (c_latency = 0 or (c_latency = 1 and c_has_o /= 0)) generate
        -- use the component rather than RTL here as it (strangely) uses fewer slices!
        mux_8to1                : c_mux_bit_8to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => 0,
            c_sync_enable     => 0,
            c_has_aclr        => 0,
            c_has_aset        => 0,
            c_has_sclr        => 0,
            c_has_sset        => 0)
          port map (
            data              => m_ext,
            sel               => s,
            sclr              => '0',
            sset              => '0',
            o                 => mux_out);
      end generate gen_lat_0_or_lat_1_with_o;

      -- We only have the sync output, so we can put all the sync controls into the
      -- muxes and stop the reg_fd implementing sync controls
      gen_lat_1_no_o : if c_latency = 1 and c_has_o = 0 generate
        -- can use more logic than an RTL mux, but will reduce the number of
        -- levels of logic for a shorter datapath
        mux_8to1     : c_mux_bit_8to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => m_ext,
            sel               => s,
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_lat_1_no_o;
    end generate gen_5to1_to_8to1_mux;

  end generate gen_2to1_to_8to1_mux;

-------------------------------------------------------------------------------
-- IF/GENERATE for mux sizes between and including 9:1 and 64:1
-------------------------------------------------------------------------------

  gen_9to1_to_64to1_mux : if c_inputs > 8 and c_inputs < 65 generate

    gen_lat_0_or_lat_1_with_o : if (c_latency = 0 or (c_latency = 1 and c_has_o /= 0 and c_has_q /= 0)) generate
      -- Implement all controls on the register or using another LUT
      gen_9to1_to_16to1       : if c_inputs > 8 and c_inputs < 17 generate
        -- Build a 16:1 RTL mux
        mux_16to1             : c_mux_bit_16to1
          generic map (
            pipelined_sub_mux => false,
            c_xdevicefamily   => c_xdevicefamily,
            c_sync_priority   => 0,
            c_sync_enable     => 0,
            c_has_aclr        => 0,
            c_has_aset        => 0,
            c_has_sclr        => 0,
            c_has_sset        => 0)
          port map (
            data              => m_ext(15 downto 0),
            sel               => s(3 downto 0),
            sclr              => '0',
            sset              => '0',
            o                 => mux_out);
      end generate gen_9to1_to_16to1;

      gen_17to1_to_32to1 : if c_inputs > 16 and c_inputs < 33 generate
        -- Build a 32:1 RTL mux
        mux_32to1        : c_mux_bit_32to1
          generic map (
            c_xdevicefamily => c_xdevicefamily,
            c_sync_priority => 0,
            c_sync_enable   => 0,
            c_has_aclr      => 0,
            c_has_aset      => 0,
            c_has_sclr      => 0,
            c_has_sset      => 0)
          port map (
            data            => m_ext(31 downto 0),
            sel             => s(4 downto 0),
            sclr            => '0',
            sset            => '0',
            o               => mux_out);
      end generate gen_17to1_to_32to1;

      gen_33to1_to_64to1 : if c_inputs > 32 and c_inputs < 65 generate
      begin
        -- Build an RTL mux
        mux_out <= m_ext(to_integer(unsigned(s)));
      end generate gen_33to1_to_64to1;
    end generate gen_lat_0_or_lat_1_with_o;

    gen_lat_1 : if (c_latency = 1 and c_pipe_stages = 0 and c_has_o = 0) generate

      gen_9to1_to_16to1 : if c_inputs > 8 and c_inputs < 17 generate
        mux_16to1       : c_mux_bit_16to1
          generic map (
            pipelined_sub_mux => false,
            c_xdevicefamily   => c_xdevicefamily,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => m_ext(15 downto 0),
            sel               => s(3 downto 0),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_9to1_to_16to1;

      gen_17to1_to_32to1 : if c_inputs > 16 and c_inputs < 33 generate
        mux_32to1        : c_mux_bit_32to1
          generic map (
            c_xdevicefamily => c_xdevicefamily,
            c_sync_priority => c_sync_priority,
            c_sync_enable   => c_sync_enable,
            c_has_aclr      => c_has_aclr,
            c_has_aset      => c_has_aset,
            c_has_sclr      => c_has_sclr,
            c_has_sset      => c_has_sset)
          port map (
            data            => m_ext(31 downto 0),
            sel             => s(4 downto 0),
            sclr            => sclr,
            sset            => sset,
            o               => mux_out);
      end generate gen_17to1_to_32to1;

      gen_33to1_to_64to1 : if c_inputs > 32 and c_inputs < 65 generate
        -- muxes between 33:1 and 64:1 will end on a 2:1 LUT mux, so will
        -- always be able to use the output register in the same slice

        gen_with_f8_no_sync : if c_has_sclr = 0 and c_has_sset = 0 generate
          -- Just build an RTL mux - don't use any of the mux components
          mux_out <= m_ext(to_integer(unsigned(s)));
        end generate gen_with_f8_no_sync;

        gen_with_f8         : if ((c_has_sclr /= 0 and c_has_sset = 0) or (c_has_sclr = 0 and c_has_sset /= 0)) generate
          -- Use the F8s (RTL 32:1 muxes) and feed them into a 2:1 mux that implements the sync control required
          mux_64to2         : for i in 0 to 1 generate
            constant offset : integer range 0 to 32 := 32;
          begin
            mux_32to1       : c_mux_bit_32to1
              generic map (
                c_xdevicefamily => c_xdevicefamily,
                c_sync_priority => 0,
                c_sync_enable   => 0,
                c_has_aclr      => 0,
                c_has_aset      => 0,
                c_has_sclr      => 0,
                c_has_sset      => 0)
              port map (
                data            => m_ext(63-(i*offset) downto 64-offset-(i*offset)),
                sel             => s(4 downto 0),
                sclr            => '0',
                sset            => '0',
                o               => lut_mux_in(1-i));
          end generate mux_64to2;

          gen_has_sclr   : if c_has_sclr /= 0 generate
            sclr_lut_mux : LUT4
              generic map(init => X"00CA")
              port map(O       => mux_out,
                       I0      => lut_mux_in(0),
                       I1      => lut_mux_in(1),
                       I2      => s(5),
                       I3      => sclr);
          end generate gen_has_sclr;

          gen_has_sset   : if c_has_sset /= 0 generate
            sset_lut_mux : LUT4
              generic map(init => X"FFCA")
              port map(O       => mux_out,
                       I0      => lut_mux_in(0),
                       I1      => lut_mux_in(1),
                       I2      => s(5),
                       I3      => sset);
          end generate gen_has_sset;
        end generate gen_with_f8;

        gen_without_f8      : if c_has_sclr /= 0 and c_has_sset /= 0 generate
          -- we have both sync controls, so implement both sync controls in
          -- the muxes - use 4x 16:1 RTL muxes feeding a 4:1 mux which implements the sync controls
          -- Do this rather than put one sync control into all 32 first-stage
          -- LUTs to reduce fan-out on these signal and make routing easier
          mux_64to2         : for i in 0 to 3 generate
            constant offset : integer range 0 to 16 := 16;
          begin
            mux_16to1       : c_mux_bit_16to1
              generic map (
                pipelined_sub_mux => false,
                c_xdevicefamily   => c_xdevicefamily,
                c_sync_priority   => 0,
                c_sync_enable     => 0,
                c_has_aclr        => 0,
                c_has_aset        => 0,
                c_has_sclr        => 0,
                c_has_sset        => 0)
              port map (
                data(15 downto 0) => m_ext(63-(i*offset) downto 64-offset-(i*offset)),
                sel               => s(3 downto 0),
                sclr              => '0',
                sset              => '0',
                o                 => lut_mux_in(3-i));
          end generate mux_64to2;
          mux_4to1          : c_mux_bit_4to1
            generic map (
              pipelined_sub_mux   => false,
              c_sync_priority     => c_sync_priority,
              c_sync_enable       => c_sync_enable,
              c_has_aclr          => c_has_aclr,
              c_has_aset          => c_has_aset,
              c_has_sclr          => c_has_sclr,
              c_has_sset          => c_has_sset)
            port map (
              data                => lut_mux_in(3 downto 0),
              sel                 => s(5 downto 4),
              sclr                => sclr,
              sset                => sset,
              o                   => mux_out);
        end generate gen_without_f8;
      end generate gen_33to1_to_64to1;

    end generate gen_lat_1;

    gen_lat_2_or_lat_1_no_op_reg : if c_latency = 2 or (c_latency = 1 and c_pipe_stages = 1) generate

      gen_9to1_to_16to1 : if c_inputs > 8 and c_inputs < 17 generate
        -- Create a mux with 4x 4:1 muxes on
        -- the input, followed by a pipeline stage then a 4:1 mux and the final output register
        -- This balances the number of levels of logic on each side of the pipeline
        -- registers, with a bias (where possible) to reducing the number of levels of
        -- logic on the input stage

        mux_16to4         : for i in 0 to 3 generate
          constant offset : integer range 0 to 4 := 4;
        begin
          mux_4to1        : c_mux_bit_4to1
            generic map (
              pipelined_sub_mux => true,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => m_ext(15-(i*offset) downto 16-offset-(i*offset)),
              sel               => s(1 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_4bit_out(3-i));
        end generate mux_16to4;

        pipe1 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => use_reg_sync_ctrls,
            c_pipe_width         => 6,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 4) & "00",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 4) & "00",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(5 downto 2)        => mux_4bit_out,   -- data
            d(1 downto 0)        => s(3 downto 2),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_6bit);

        mux_4to1_out : c_mux_bit_4to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => pipe_out_6bit(5 downto 2),
            sel               => pipe_out_6bit(1 downto 0),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_9to1_to_16to1;

      ---------------------------------------------------------------------------
      -- 17:1 to 32:1 latency 2 mux
      ---------------------------------------------------------------------------
      gen_17to1_to_32to1 : if c_inputs > 16 and c_inputs < 33 generate

        mux_32to8         : for i in 0 to 7 generate
          constant offset : integer range 0 to 4 := 4;
        begin
          mux_4to1        : c_mux_bit_4to1
            generic map (
              pipelined_sub_mux => true,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => m_ext(31-(i*offset) downto 32-offset-(i*offset)),
              sel               => s(1 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_8bit_out(7-i));
        end generate mux_32to8;

        pipe1 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => use_reg_sync_ctrls,
            c_pipe_width         => 11,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 8) & "000",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 8) & "000",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(10 downto 3)       => mux_8bit_out,   -- data
            d(2 downto 0)        => s(4 downto 2),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_11bit);

        mux_8to1 : c_mux_bit_8to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => pipe_out_11bit(10 downto 3),
            sel(2 downto 0)   => pipe_out_11bit(2 downto 0),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_17to1_to_32to1;

      -----------------------------------------------------------------------------
      -- 33:1 to 64:1 latency 2 mux
      -----------------------------------------------------------------------------
      gen_33to1_to_64to1 : if c_inputs > 32 and c_inputs < 65 generate

        mux_256to1        : for i in 0 to 7 generate
          constant offset : integer range 0 to 8 := 8;
        begin
          mux_8to1        : c_mux_bit_8to1
            generic map (
              pipelined_sub_mux => true,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => m_ext(63-(i*offset) downto 64-offset-(i*offset)),
              sel               => s(2 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_8bit_out(7-i));
        end generate mux_256to1;

        pipe1 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => use_reg_sync_ctrls,
            c_pipe_width         => 11,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 8) & "000",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 8) & "000",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(10 downto 3)       => mux_8bit_out,   -- data
            d(2 downto 0)        => s(5 downto 3),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_11bit);

        mux_8to1_out : c_mux_bit_8to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => pipe_out_11bit(10 downto 3),
            sel(2 downto 0)   => pipe_out_11bit(2 downto 0),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_33to1_to_64to1;

    end generate gen_lat_2_or_lat_1_no_op_reg;

  end generate gen_9to1_to_64to1_mux;

-------------------------------------------------------------------------------
-- IF/GENERATE for mux sizes between and including 65:1 and 256:1
-------------------------------------------------------------------------------

  gen_65to1_to_256to1_mux : if c_inputs > 64 and c_inputs < 257 generate

    gen_lat_0 : if (c_latency = 0 or (c_latency = 1 and c_has_o /= 0 and c_has_q /= 0)) generate
      -- just build an RTL mux
      mux_out <= m(to_integer(unsigned(s)));
    end generate gen_lat_0;

    gen_lat_1             : if c_latency = 1 and c_has_o = 0 generate
      -- build RTL 32:1 muxes and mux these with a 4:1 mux
      -- implementing whatever sync controls are needed
      gen_65to1_to_128to1 : if c_inputs > 64 and c_inputs < 129 generate
        mux_128to4        : for i in 0 to 3 generate
          constant offset : integer range 0 to 32 := 32;
        begin
          mux_32to1       : c_mux_bit_32to1
            generic map (
              c_xdevicefamily   => c_xdevicefamily,
              c_sync_priority   => 0,
              c_sync_enable     => 0,
              c_has_aclr        => 0,
              c_has_aset        => 0,
              c_has_sclr        => 0,
              c_has_sset        => 0)
            port map (
              data(31 downto 0) => m_ext(127-(i*offset) downto 128-offset-(i*offset)),
              sel               => s(4 downto 0),
              sclr              => '0',
              sset              => '0',
              o                 => lut_mux_in(3-i));
        end generate mux_128to4;

        mux_4to1 : c_mux_bit_4to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => lut_mux_in(3 downto 0),
            sel               => s(6 downto 5),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_65to1_to_128to1;

      gen_129to1_to_256to1 : if c_inputs > 128 and c_inputs < 257 generate
        mux_256to8         : for i in 0 to 7 generate
          constant offset  : integer range 0 to 32 := 32;
        begin
          mux_32to1        : c_mux_bit_32to1
            generic map (
              c_xdevicefamily   => c_xdevicefamily,
              c_sync_priority   => 0,
              c_sync_enable     => 0,
              c_has_aclr        => 0,
              c_has_aset        => 0,
              c_has_sclr        => 0,
              c_has_sset        => 0)
            port map (
              data(31 downto 0) => m_ext(255-(i*offset) downto 256-offset-(i*offset)),
              sel               => s(4 downto 0),
              sclr              => '0',
              sset              => '0',
              o                 => mux_8bit_out(7-i));
        end generate mux_256to8;

        mux_8to1_0 : c_mux_bit_8to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => mux_8bit_out(7 downto 0),
            sel               => s(7 downto 5),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_129to1_to_256to1;

    end generate gen_lat_1;

    gen_lat_2 : if c_latency = 2 generate
      -- output register plus pipelining (2 sub-mux stages)

      ---------------------------------------------------------------------------
      -- 65:1 to 128:1 latency 2 mux
      ---------------------------------------------------------------------------
      gen_65to1_to128to1 : if c_inputs > 64 and c_inputs < 129 generate

        mux_128to8        : for i in 0 to 15 generate
          constant offset : integer range 0 to 8 := 8;
        begin
          mux_8to1        : c_mux_bit_8to1
            generic map (
              pipelined_sub_mux => true,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => m_ext(127-(i*offset) downto 128-offset-(i*offset)),
              sel               => s(2 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_16bit_out(15-i));
        end generate mux_128to8;

        pipe1 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => use_reg_sync_ctrls,
            c_pipe_width         => 20,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 16) & "0000",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 16) & "0000",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(19 downto 4)       => mux_16bit_out,  -- data
            d(3 downto 0)        => s(6 downto 3),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_20bit);

        mux_16to1 : c_mux_bit_16to1
          generic map (
            pipelined_sub_mux => false,
            c_xdevicefamily   => c_xdevicefamily,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => pipe_out_20bit(19 downto 4),
            sel(3 downto 0)   => pipe_out_20bit(3 downto 0),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);

      end generate gen_65to1_to128to1;

      -----------------------------------------------------------------------------
      -- 129:1 to 256:1 latency 2 mux
      -----------------------------------------------------------------------------
      gen_129to1_to_256to1 : if c_inputs > 128 and c_inputs < 257 generate

        mux_256to16       : for i in 0 to 15 generate
          constant offset : integer range 0 to 16 := 16;
        begin
          mux_16to1       : c_mux_bit_16to1
            generic map (
              pipelined_sub_mux => true,
              c_xdevicefamily   => c_xdevicefamily,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => m_ext(255-(i*offset) downto 256-offset-(i*offset)),
              sel               => s(3 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_16bit_out(15-i));
        end generate mux_256to16;

        pipe1 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => use_reg_sync_ctrls,
            c_pipe_width         => 20,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 16) & "0000",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 16) & "0000",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(19 downto 4)       => mux_16bit_out,  -- data
            d(3 downto 0)        => s(7 downto 4),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_20bit);

        mux_16to1_out : c_mux_bit_16to1
          generic map (
            pipelined_sub_mux => false,
            c_xdevicefamily   => c_xdevicefamily,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => pipe_out_20bit(19 downto 4),
            sel               => pipe_out_20bit(3 downto 0),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_129to1_to_256to1;

    end generate gen_lat_2;

    gen_lat_3 : if c_latency = 3 generate

      ---------------------------------------------------
      -- 65:1 to 128:1 latency 3 mux
      ---------------------------------------------------
      gen_65to1_to128to1 : if c_inputs > 64 and c_inputs < 129 generate

        -- Create a mux with 32x 4:1 muxes on
        -- the input, followed by a pipeline stage then 4x 8:1 muxes then the second
        -- pipeline stage, a 4:1 mux and the final output register
        -- This minimises the number of levels of logic on the input stage whilst using a reasonable amount of resources

        -- Break the 128-bit vector into 32x 4-bit
        -- vectors for the first mux stage

        mux_128to32       : for i in 0 to 31 generate
          constant offset : integer range 0 to 4 := 4;
        begin
          mux_4to1        : c_mux_bit_4to1
            generic map (
              pipelined_sub_mux => true,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => m_ext(127-(i*offset) downto 128-offset-(i*offset)),
              sel               => s(1 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_32bit_out(31-i));
        end generate mux_128to32;

        pipe1 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => use_reg_sync_ctrls,
            c_pipe_width         => 37,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 32) & "00000",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 32) & "00000",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(36 downto 5)       => mux_32bit_out,  -- data
            d(4 downto 0)        => s(6 downto 2),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_37bit);

        mux_32to4         : for i in 0 to 3 generate
          constant offset : integer range 0 to 8 := 8;
        begin
          mux_8to1        : c_mux_bit_8to1
            generic map (
              pipelined_sub_mux => true,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => pipe_out_37bit(36-(i*offset) downto 37-offset-(i*offset)),
              sel               => pipe_out_37bit(2 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_4bit_out(3-i));
        end generate mux_32to4;

        pipe2 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => use_reg_sync_ctrls,
            c_pipe_width         => 6,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 4) & "00",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 4) & "00",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(5 downto 2)        => mux_4bit_out,                -- data
            d(1 downto 0)        => pipe_out_37bit(4 downto 3),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_6bit);

        mux_4to1 : c_mux_bit_4to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => pipe_out_6bit(5 downto 2),
            sel               => pipe_out_6bit(1 downto 0),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_65to1_to128to1;

      -----------------------------------------
      -- 129:1 to 256:1 latency 3 mux
      -----------------------------------------
      gen_129to1_to_256to1 : if (c_inputs > 128 and c_inputs < 257) generate

        mux_256to64       : for i in 0 to 63 generate
          constant offset : integer range 0 to 4 := 4;
        begin
          mux_4to1        : c_mux_bit_4to1
            generic map (
              pipelined_sub_mux => true,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => m_ext(255-(i*offset) downto 256-offset-(i*offset)),
              sel               => s(1 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_64bit_out(63-i));
        end generate mux_256to64;

        pipe1 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => false,
            c_pipe_width         => 70,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 64) & "000000",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 64) & "000000",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(69 downto 6)       => mux_64bit_out,  -- data
            d(5 downto 0)        => s(7 downto 2),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_70bit);

        mux_64to8         : for i in 0 to 7 generate
          constant offset : integer range 0 to 8 := 8;
        begin
          mux_8to1        : c_mux_bit_8to1
            generic map (
              pipelined_sub_mux => true,
              c_sync_priority   => c_sync_priority,
              c_sync_enable     => c_sync_enable,
              c_has_aclr        => c_has_aclr,
              c_has_aset        => c_has_aset,
              c_has_sclr        => c_has_sclr,
              c_has_sset        => c_has_sset)
            port map (
              data              => pipe_out_70bit(69-(i*offset) downto 70-offset-(i*offset)),
              sel               => pipe_out_70bit(2 downto 0),
              sclr              => sclr,
              sset              => sset,
              o                 => mux_8bit_out(7-i));
        end generate mux_64to8;

        pipe2 : c_mux_bit_pipereg
          generic map(
            c_mux_inputs         => c_inputs,
            c_use_reg_sync_ctrls => false,
            c_pipe_width         => 11,
            c_ainit_val          => fn_stretch_string(c_ainit_val, 8) & "000",
            c_sinit_val          => fn_stretch_string(c_sinit_val, 8) & "000",
            c_sync_enable        => c_sync_enable,
            c_sync_priority      => c_sync_priority,
            c_has_ce             => c_has_ce,
            c_has_aclr           => c_has_aclr,
            c_has_aset           => c_has_aset,
            c_has_sclr           => c_has_sclr,
            c_has_sset           => c_has_sset)
          port map(
            d(10 downto 3)       => mux_8bit_out,                -- data
            d(2 downto 0)        => pipe_out_70bit(5 downto 3),  -- select lines
            clk                  => clk,
            ce                   => ce,
            aclr                 => aclr,
            aset                 => aset,
            sclr                 => sclr,
            sset                 => sset,
            q                    => pipe_out_11bit);

        mux_8to1 : c_mux_bit_8to1
          generic map (
            pipelined_sub_mux => false,
            c_sync_priority   => c_sync_priority,
            c_sync_enable     => c_sync_enable,
            c_has_aclr        => c_has_aclr,
            c_has_aset        => c_has_aset,
            c_has_sclr        => c_has_sclr,
            c_has_sset        => c_has_sset)
          port map (
            data              => pipe_out_11bit(10 downto 3),
            sel               => pipe_out_11bit(2 downto 0),
            sclr              => sclr,
            sset              => sset,
            o                 => mux_out);
      end generate gen_129to1_to_256to1;

    end generate gen_lat_3;

  end generate gen_65to1_to_256to1_mux;

  -- Depending on generics, the mux may or may not have an async output
  gen_o : if c_has_o /= 0 generate
    o <= mux_out;
  end generate gen_o;

  gen_output_reg : if c_has_q /= 0 generate
    pipe1        : c_mux_bit_pipereg
      generic map(
        c_mux_inputs         => c_inputs,
        c_use_reg_sync_ctrls => use_reg_sync_ctrls,
        c_pipe_width         => 1,
        c_ainit_val          => c_ainit_val,
        c_sinit_val          => c_sinit_val,
        c_sync_enable        => c_sync_enable,
        c_sync_priority      => c_sync_priority,
        c_has_ce             => c_has_ce,
        c_has_aclr           => c_has_aclr,
        c_has_aset           => c_has_aset,
        c_has_sclr           => c_has_sclr,
        c_has_sset           => c_has_sset)
      port map(
        d(0)                 => mux_out,
        clk                  => clk,
        ce                   => ce,
        aclr                 => aclr,
        aset                 => aset,
        sclr                 => sclr,
        sset                 => sset,
        q(0)                 => q);
  end generate gen_output_reg;

end architecture synth;



-- (c) Copyright 1995 - 2013 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

library c_mux_bit_v12_0_3;
use c_mux_bit_v12_0_3.c_mux_bit_v12_0_3_viv_comp.all;

entity c_mux_bit_v12_0_3 is
  generic (
    C_FAMILY        : string  := "virtex2";  -- Specifies device family being targeted
    C_XDEVICEFAMILY : string  := "virtex2";  -- Specifies device family being targeted
    C_INPUTS        : integer := 2;          -- Specifies input data bus width to mux
    C_SEL_WIDTH     : integer := 1;          -- Specifies select bus width
    C_PIPE_STAGES   : integer := 0;          -- Specifies number of pipeline stages in conj. with c_latency (0,1,2)
    C_LATENCY       : integer := 1;          -- Specifies latency of mux (0,1,2,3)
    C_HEIGHT        : integer := 0;          -- Redundant in VHDL core
    C_AINIT_VAL     : string  := "0";        -- Async init value, defaults to 0 in the code, init value for registers
    C_SINIT_VAL     : string  := "0";        -- Sync init value, redundant here
    C_SYNC_ENABLE   : integer := 0;          -- Priority of CE and sync controls - passed to o/p register
    C_SYNC_PRIORITY : integer := 1;          -- Priority of sync set and clear for output register
    C_HAS_O         : integer := 0;          -- Unregistered output
    C_HAS_Q         : integer := 1;          -- Registered output
    C_HAS_CE        : integer := 0;          -- Optional clock enable
    C_HAS_ACLR      : integer := 0;          -- Optional async clear
    C_HAS_ASET      : integer := 0;          -- Optional async set
    C_HAS_AINIT     : integer := 0;          -- Redundant async init - for interface only
    C_HAS_SCLR      : integer := 0;          -- Optional sync clear
    C_HAS_SSET      : integer := 0;          -- Optional sync set
    C_HAS_SINIT     : integer := 0;          -- Redundant sync init - for interface only
    C_ENABLE_RLOCS  : integer := 0           -- Redundant in VHDL core
    );

  port (
    M     : in  std_logic_vector(C_INPUTS-1 downto 0)    := (others => '0');  -- Input vector
    S     : in  std_logic_vector(C_SEL_WIDTH-1 downto 0) := (others => '0');  -- Select pin
    CLK   : in  std_logic                                := '0';              -- Optional clock
    CE    : in  std_logic                                := '1';              -- optional clock enable
    ASET  : in  std_logic                                := '0';              -- Optional asynch set '1'
    ACLR  : in  std_logic                                := '0';              -- Optional asynch clear to '0'
    AINIT : in  std_logic                                := '0';              -- Redundant in this version
    SSET  : in  std_logic                                := '0';              -- Optional synch set to '1'
    SCLR  : in  std_logic                                := '0';              -- Optional synch clear to '0'
    SINIT : in  std_logic                                := '0';              -- Redundant in this version
    O     : out std_logic                                := '0';              -- Output value
    Q     : out std_logic                                := '0'               -- Registered output value
    );

  -- Choose to optimise away equivalent registers for the cases where the mux
  -- vector has constants present in it (e.g. 17:1 pipelined mux)
end entity c_mux_bit_v12_0_3;

architecture xilinx of c_mux_bit_v12_0_3 is

  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of xilinx : architecture is "yes";

begin
  xstmuxbitinst : c_mux_bit_v12_0_3_viv
  generic map (
    C_FAMILY => C_FAMILY,
    C_XDEVICEFAMILY => C_XDEVICEFAMILY,
    C_INPUTS => C_INPUTS,
    C_SEL_WIDTH => C_SEL_WIDTH,
    C_PIPE_STAGES => C_PIPE_STAGES,
    C_LATENCY => C_LATENCY,
    C_HEIGHT => C_HEIGHT,
    C_AINIT_VAL => C_AINIT_VAL,
    C_SINIT_VAL => C_SINIT_VAL,
    C_SYNC_ENABLE => C_SYNC_ENABLE,
    C_SYNC_PRIORITY => C_SYNC_PRIORITY,
    C_HAS_O => C_HAS_O,
    C_HAS_Q => C_HAS_Q,
    C_HAS_CE => C_HAS_CE,
    C_HAS_ACLR => C_HAS_ACLR,
    C_HAS_ASET => C_HAS_ASET,
    C_HAS_AINIT => C_HAS_AINIT,
    C_HAS_SCLR => C_HAS_SCLR,
    C_HAS_SSET => C_HAS_SSET,
    C_HAS_SINIT => C_HAS_SINIT,
    C_ENABLE_RLOCS => C_ENABLE_RLOCS
  )
  port map (
    M => M,
    S => S,
    CLK => CLK,
    CE => CE,
    AINIT => AINIT,
    ASET => ASET,
    ACLR => ACLR,
    SINIT => SINIT,
    SSET => SSET,
    SCLR => SCLR,
    O => O,
    Q => Q
  );
  
end architecture xilinx;




